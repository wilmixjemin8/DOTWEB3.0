

DOTWEB3.0ProgrammingLanguageTutorial
=====================================

===========================================================================
UNIT 1:  Introduction to    DOTWEB3.0 Programming  Language
                                                                     
===========================================================================
Introduction

DOTWEB3.0  is otherwise  known  as  JWEB or DOTWEB3.0 Programming  Language

Definition:
=========
 "DOTWEB3.0 is an interactive , System programming,  OOPS,  Multipurpose, Advanced   Technology  ,Advanced Business Programming  Language focused  on  remote webapplications, web   and GUI development".
Meaning :  DOTWEB3.0  stands    for   Success  and  prosperity  and it is the

  Wilmix jemin  Developed  a   Advanced  Programming  Language which  is 
DOTWEB3.0  in  year  2013  by  using   CH$  programming  Language.
JWEB  means  JDollar  Wilmix  for  External Business.
DOTWEB3.0    tutorial  is  a  very lengthy  tutorial   it  is  based   on   CH$ oops  concepts.
JWEB  accepts  only  .dll  , .class , and  .exe  other  things   JWEB  compiler  will not  understood  anything.

ABOUT DOTWEB3.0 Programming Language
====================================

DOTWEB3.0 also supports webapplication,remote webapplication,cloud computing, Research,Inventing OS, compilers,RAI,webservices,etc.
The major advantage in JDollar is high security,vast  memory  storage, interaction, and  include  new  concepts like  Tabernacle,   J$Saucer,etc
DOTWEB3.0 has many frameworks and latest technologies than java.JDollar itself a Big sky technology.
DOTWEB3.0(JWEB) maintains shortest code which maintain High qualities.Another major advantage of DOTWEB3.0(JWEB) is Advanced business.
DOTWEB3.0  is   150 times  Greater   than  JAVA.So  it  is    called   as  Advanced   Programming  Language.DOTWEB3.0   has   many  servers  focused  on   many  projects.

 Merits of  DOTWEB3.0
 ===============
> It is Good to create any compilers..and Advanced Operating systems,easy  to  focus, learnable, interaction,AdvancedBusiness, and utilities.
> It has simpilified code
>  it  is     learnable  ,easy  to use, and   let  developers to  focus  only    C#/JAVA/C++/CH$  Programming  Language
>  it  can  be  used   to  execute   .exe  files.

Core DOTWEB3.0
===============

Extension:  .jdollar(simillar to Advanced  OOPS with  JUTIL and CH$ combination) called as JWEB  accepting only   .exe   and  .dll   files.
Let  us  see  more  briefly  about  Core  JDollar(JWEB).....

KEYWORDS
 <JDollar>   
abstract     add     as     ascending
 async     await     base     bool
 break     by     byte     case
 catch     char     checked     <CLASS>
 const     continue     decimal     default
 delegate     descending     do     double
 dynamic     else     enum     <EQUALS>
 explicit     extern     false     finally
 fixed     float     for     foreach
 from     get     global    goto
group     if     implicit     in
 int     interface     internal     into
 is     join     let     lock
 long     <PACK>     <NEW>     null 
 object     on     operator     orderby
 out     override     params     partial
 private     protected     public     readonly
 ref     remove     return     sbyte
 sealed     select     set     short
 sizeof     stackalloc     Shared     string
 struct     switch     this     throw
 true     <TRY>     typeof     uint
 ulong     unchecked     unsafe     ushort
 using     value     var     virtual
 void     volatile     where     while
 yield  <%   %>


OTHER KEYWORDS IN JDOLLAR
--------------------------------------------------
AND -> AND operator
NOT -> NOT operator
# -> NOTEQUALS
RUN -> Runnable used in thread
TH-> Thread
<EXE> -> Exception
Friends -> Frend function
eg)

int  a=2;
int  b=3;

if (( a ==2)AND  (b==3))

<PRINTLN>("wilmix");
    

OTHER ATTRACTIVE SYMBOLS in JDOLLAR
-------------------------------------------
--> => implements
<-- => extends

DATATYPES
JDollar  DATATYPES

The eight primitive data types in Java are:
boolean, the type whose values are either true or false.
char, the character type whose values are 16-bit Unicode characters

the arithmetic types, the integral types:
byte
short
int
long
the floating-point types:
float
double
Values of class type are references. Strings are references to an instance of class String.
Primitive Data Types
There are eight primitive datatypes supported by  CDollarc. Primitive datatypes are predefined by the language and named by a keyword. Let us now look into the eight primitive data types in detail.
Byte
Byte data type is an 8-bit signed two's complement integer
Minimum value is -128 (-2^7)
Maximum value is 127 (inclusive)(2^7 -1)
Default value is 0
Byte data type is used to save space in large arrays, mainly in place of integers, since a byte is four times smaller than an integer.
Example: byte a = 800, byte b = -850
Short
Short data type is a 16-bit signed two's complement integer
Minimum value is -32,768 (-2^15)
Maximum value is 32,767 (inclusive) (2^15 -1)
Short data type can also be used to save memory as byte data type. A short is 2 times smaller than an integer
Default value is 0.
Example: short s = 77000, short r = -880000
int
Int data type is a 32-bit signed two's complement integer.
Minimum value is - 2,147,483,648 (-2^31)
Maximum value is 2,147,483,647(inclusive) (2^31 -1)
Integer is generally used as the default data type for integral values unless there is a concern about memory.
The default value is 0
Example: int a = 340000, int b = -7600000
long
Long data type is a 64-bit signed two's complement integer
Minimum value is -9,223,372,036,854,775,808(-2^63)
Maximum value is 9,223,372,036,854,775,807 (inclusive)(2^63 -1)
This type is used when a wider range than int is needed
Default value is 0L
Example: long a = 34990L, long b = -92000000L
float
Float data type is a single-precision 32-bit IEEE 754 floating point
Float is mainly used to save memory in large arrays of floating point numbers
Default value is 0.0f
Float data type is never used for precise values such as currency
Example: float f1 = 54.5f
double
double data type is a double-precision 64-bit IEEE 754 floating point
This data type is generally used as the default data type for decimal values, generally the default choice
Double data type should never be used for precise values such as currency
Default value is 0.0d
Example: double d1 = 15.2
boolean
boolean data type represents one bit of information
There are only two possible values: true and false
This data type is used for simple flags that track true/false conditions
Default value is false
Example: boolean one = true
Char
char data type is a single 16-bit Unicode character
Char data type is used to store any character
Example: char letterA = 'S'
Conditional Operator ( ? : ) in  JDollarc
Conditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate Boolean expressions. The goal of the operator is to decide, which value should be assigned to the variable. The operator is written as −
variable x = (expression) ? value if true : value if false

PRIMITIVE  DATATYPES  in  JDOLLARCC
The following table lists the available value types in JDollarc (v.1)
bool    Boolean value    True or False    False
byte    8-bit unsigned integer    0 to 255    0
char    16-bit Unicode character    U +0000 to U +ffff    '\0'
decimal    128-bit precise decimal values with 28-29 significant digits    (-7.9 x 1028 to 7.9 x 1028) / 100 to 28    0.0M
double    64-bit double-precision floating point type    (+/-)5.0 x 10-324 to (+/-)1.7 x 10308    0.0D
float    32-bit single-precision floating point type    -3.4 x 1038 to + 3.4 x 1038    0.0F
int    32-bit signed integer type    -2,147,483,648 to 2,147,483,647    0
long    64-bit signed integer type    -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807    0L
sbyte    8-bit signed integer type    -128 to 127    0
short    16-bit signed integer type    -32,768 to 32,767    0
uint    32-bit unsigned integer type    0 to 4,294,967,295    0
ulong    64-bit unsigned integer type    0 to 18,446,744,073,709,551,615    0
ushort    16-bit unsigned integer type    0 to 65,535    0

OPERATORS  in  JDollarcc
Operator Type    Category    Precedence
Unary    postfix    expr++ expr--
prefix    ++expr --expr +expr -expr ~ !
Arithmetic    multiplicative    * / %
additive    + -
Shift    shift    << >> >>>
Relational    comparison    < > <= >= instanceof
equality    ==  NOT=
Bitwise    bitwise AND    &
bitwise exclusive OR    ^
bitwise inclusive OR    |
Logical    logical AND    AND
logical OR    OR
Ternary    ternary    ? :
Assignment    assignment    = += -= *= /= %= &= ^= |= <<= >>= >>>=


JDollar  has the  following type of operators:
•Arithmetic Operators
•Relational Operators
•Logical Operators
•Bitwise Operators
•Assignment Operators
•Misc Operators
•Arithmetic Operators
Example:
Assume variable A holds 1 and variable B holds 7 then:


Operator    Description    Example
+    Adds two operands    A + B = 8
-    Subtracts second operand from the first    A - B = -6
*    Multiplies both operands    A * B = 7
/    Divides numerator by de-numerator    B / A = 7
%    Modulus Operator and remainder of after an integer division    B % A = 0
++    Increment operator increases integer value by one    A++ = 2
--    Decrement operator decreases integer value by one    A-- = 0

Relational Operators
Assume variable A holds 30 and variable B holds 10, then:

Show Examples
Operator    Description    Example
==    Checks if the values of two operands are equal or not, if yes then condition becomes true.    (A == B) is not true.
!=    Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.    (A != B) is true.
>    Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.    (A > B) is  true.
<    Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.    (A < B) is not true.
>=    Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.    (A >= B) is  true.
<=    Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.    (A <= B) is not true.
Logical Operators
Assume variable A holds Boolean value true and variable B holds Boolean value false, then:
Operator    Description    Example
&&    Called Logical AND operator. If both the operands are non zero then condition becomes true.    (A && B) is false.
||    Called Logical OR Operator. If any of the two operands is non zero then condition becomes true.    (A || B) is true.
!    Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.    !(A && B) is true.

Bitwise Operators
Bitwise operator works on bits and perform bit by bit operation. The truth tables for &, |, and ^ are as follows:
p    q    p & q    p | q    p ^ q
0    0    0    0    0
0    1    0    1    1
1    1    1    1    0
1    0    0    1    1

Operator    Description    Example
&    Binary AND Operator copies a bit to the result if it exists in both operands.
|    Binary OR Operator copies a bit if it exists in either operand.
^    Binary XOR Operator copies the bit if it is set in one operand but not both.    
~    Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.    
<<    Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.    
>>    Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.    

Assignment Operators
There are following assignment operators supported by CDollarcc:


Operator    Description    Example
=    Simple assignment operator, Assigns values from right side operands to left side operand    C1 = A1 + B1 assigns value of A1 + B1 into C1
+=    Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand    C 1+= A1 is equivalent to C 1= C1 + A1
-=    Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand    C1 -= A1 is equivalent to C 1= C1 - A1
*=    Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand    C1 *= A1 is equivalent to C1 = C1 * A1
/=    Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand    C 1/= A1  is equivalent to C1 = C1 / A1
%=    Modulus AND assignment operator, It takes modulus using two operands and assign the result to left operand    C1 %= A1 is equivalent to C1 = C1 % A1
<<=    Left shift AND assignment operator    C1 <<= 2 is same as C1 = C1 << 2
>>=    Right shift AND assignment operator    C 1>>= 2 is same as C 1= C1 >> 2
&=    Bitwise AND assignment operator    C1 &= 2 is same as C 1= C1 & 2
^=    bitwise exclusive OR and assignment operator    C1 ^= 2 is same as C1 = C1 ^ 2
|=    bitwise inclusive OR and assignment operator    C1 |= 2 is same as C1 = C1 | 2

Miscellaneous Operators
There are few other important operators including sizeof, typeof and ? : supported by Jdollarc.


Operator    Description    Example
sizeof()    Returns the size of a data type.    sizeof(int), returns 4.
typeof()    Returns the type of a class.    typeof(StreamReader);
&    Returns the address of an variable.    ANDa;  returns actual address of the variable.
*    Pointer to a variable.    *a  creates pointer named 'a' to a variable.
? :    Conditional Expression    If Condition is true ? Then value A : Otherwise value B
is    Determines whether an object is of a certain type.    If( Girafee is animal) // checks if Girafee is an object of the Animal class.
as    Cast without raising an exception if the cast fails.    Object obj = new StringReader("Wilmix");
StringReader r = obj as StringReader

Operator Precedence in JDollarc
Operator precedence of  the  expression.some operators have higher precedence than others; for example, the multiplication  or  division  operator has higher precedence than the addition operator.
For example x = 6 + 12 * 2; here, x is assigned 30, not 36 because operator * has higher precedence than +, so the first evaluation takes place for 12*2 and then 6 is added into it.
Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators are evaluated first.
Category    Operator    Associativity
Postfix    () [] -> . ++ - -    Left to right
Unary    + - ! ~ ++ - - (type)* & sizeof    Right to left
Multiplicative    * / %    Left to right
Additive    + -    Left to right
Shift    << >>    Left to right
Relational    < <= > >=    Left to right
Equality    ==  NOT=    Left to right
Bitwise AND    &    Left to right
Bitwise XOR    ^    Left to right
Bitwise OR    |    Left to right
Logical AND    AND    Left to right
Logical OR    OR    Left to right
Conditional    ?:    Right to left
Assignment    = += -= *= /= %=>>= <<= &= ^= |=    Right to left
Comma    ,    Left to right
========================================================
CORE JDOLLAR(JWEB)

SYNTAX FOR JDOLLAR(JWEB) (.jdollar) (beautiful syntax)
---------------------------------------------------------------

<JDollar>
<IMPORT>  //  to  load  JDollar  packages
<USE> PACKAGES;
<PACK>  <namespacename>  //  pack  will   act  like   namespace
{
   <CLASS> <Classname>
   {
      public void main()
      {
       <!  JWEB  LOGIC  !>
      }
   }
}

note: This should be saved in filename.jdollar
----
History  about  how   JDollar(JWEB)  formed?

At   Year  2013  wilmix  jemin    worked  in Developing  a   userfriendly  framework  in  java.  But  he  notice  a   demerits in  java  that   java  source  code  can  be  taken  using  JAD decompiler. That is   Jad  decompiler  can easily convert  .class   file  to  java  file easily.  So  it   is  more   difficult   to  invent  a  technology and framework   in  java/j2ee.  By  using  Spring  and  Hibernate  it  takes  long  time  to  complete  it   for  a  huge  project.  So  if  a  small  company  take  more   employees  and  fails  in  project  by  using  java/j2ee. Then  it  will  bring   more  loss  for  the  company.
Another  one   demerits  in  java  is    Developers  had  to  spend  more  time   in  writing  code .  JDollar(JWEB)  provides  a  optimized   and  obsucated  code  than  any  technology.
If  you look  on  Dotnet  demerits  ; Dotnet  source  code  can  be  taken using  code reflector.  So  both  the   technologies  failed    at   90% .  So  I  suggest  to  invent  a   helper  and  friendly  technology  for  both  technology  java  and  dotnet ie)  known  as  Jdollar(JWEB). java/j2ee  on  the  other  hand  completly  fails   ;
In the  same  way  php  Technology  also  fails  since    so  it  is   difficult  for  a  client  to  handle  big  projects..  if  you  run  a  php  wamp server   and  right  click the  mouse  on  the  browser  you can  easily  take  what  php  code  is  written. So  client  cannot  focus  webdesign  by  using  php  technology. so  i  suggest  to  invent  a  technology  known  as  JSTAR  technology  which  is  focused    for   webdesign.
Demerits  of  Computer  field
Computer  field    is  like  a   ship  sails  in  a  sea  when a fisherman  put  a  Net   he  will  get   fishes  at  a   particular   season  not at  all  seasons   of  the year.  If  a  company  did  not   get  a   project  at  particular  time  ;  developers  will  be  at  bench; Mostly  many developers  focus  on java oops  concepts  results  in  more  competition. Only  60%   developers  will be  selected  for  a  project  at  a  time. When  the  developers  will  at  bench  for  a long  time    he will   be  kicked  out  of  the  company   results  in  unemployment. So  the  competition  is   due  to  lack of  projects  available  at  a time and  developers  focus  only  on  java  oops  concepts   result   in  competition  and  unemployement..
So What   is    the  solution  for  that?
How   to  Overtake  Demerits  of    Computer  field?
JDollar(JWEB), DOTWEB,JSWORD   have  Advanced  business  to   balance  the  computer  field  and  to  make  projects  available  at  any  time..  This   results  in  cooperation  ,unity, save time  and  cost ;  and it  will   build  friendship  among  co-workers..  JDollar(JWEB)  will  bring  Prosperity ,unity,vast memory storage mgt  and  high  security.
Now  we  see    Sample   JDollar(JWEB)  program  with  explanation which  is  given  below....

MY  FIRST  JDollar(JWEB)  Program

Program-1 (example)
=========

<JDollar>
<PACK> MyP
{
      <CLASS> HEAP
    {
         public void main()
        {
        Heap root <NEW> Heap("wilmix");
        
        for (int i = 0; i <= 10; i = i + 1)
        {
            root.add("item " + i);
        }
                 
        <PRINTLN>(root.size() );
        root.printTree();        
}
}
}
Now  11  elements  including  wilmix are  added  in  HEAP  datastructure   of  JDollar.
So  it  will  print  it  in  tree  format.
 
Output:
----------
>heap.Jdollar.exe
12
item 6
item 2
item 10
item 0
item 8
item 4
wilmix
item 7
item 3
item 1
item 9
item 5

Program-2
==========
<JDollar>
<PACK> MyP
{
      <CLASS> LArray1
    {
         public void main()
        {
        LArray root = new LArray("root");    
        root.add("wilmix");
        root.add("jemin");
        root.add("shalom");
        root.add("1010");
        root.add("101");
        root.add("201");
        root.add("100000000");
        //print the tree's size and contents
        root.printTree();
}
}
}

We  already     know  about LArray   ;  we  already  learnt  in  CDollar p.l.
=========================================================  

How to run remoteserver in windows?

click  on  JDOLLARSERVER   located   at  JDOLLAR  folder.
note : default  hostname  is  localhost  or ip  address.

Why  we   need   remotewebapplication?  what  is  the  difference  between  webapplication   and  this?

webapplication   webpages   will  not   travel   around   web
but  remotewebapplication is  seen  in internet ,mobiles,
and all  devices.

What  is   HARP  or  X Remote webapplication? 
 HARP  remote webapplication   means  any  guys
can store  high volume  of  data and  retrieve  data  from  memory  
and  it  can  be  used  like  a very  huge  bigdata  with cloud  
computing  focused  on   remote webapplication ;  this  kind  of  
remote  webapplication  is  otherwise  known  as  HARP 
or  X remote  webapplication.
X  stands   for  Advanced  remotewebapplication.
that   we  can  see   more  detail  in  DOTWEB3.0
but  in   this    tutorial    we   will   learn  more  details  
about  fundamentals  of  JDollar(JWEB) and  it's  advantages
using   webapplication   and  remotewebapplication-type-2.
=========================================================
UNIT  -2:  a)  JDollar  with  CDollar  And  Advantages  over other  P.L.
=========================================================

CDOLLAR-JDOLLAR-MODULE-1
=========================

CDOLLAR-JDollar   is  used    in  Linux platform.

How Cdollar-J$ Technology Works?
––––––––––––––––––––––––––––––––-
At first .cdollar or .c$ is compiled by Cdollarc compiler
And it translate to .C$ file with intermediate  encode  code.
Cdollarv.4 translator uses CDC friend compiler Which compiles
the Cdollar program.
After that Cdollarv.4 translates to .wl class files and use
CDRUN filename.wl automatically to run the Program.
So converting the bytes codes in .wl class file makes the progam
to run faster than other compilers..

=========================================================
C D O L L A R-JDOLLAR -PROGRAMMING-TUTORIAL
--------------------------------------------------
Written By wilmix jemin j
=========================================================

INTRODUCTION
------------

Why CDollar?
-------------
CDollar is used for creating libraries ; CDollar is formed in C/C++
in year 2004.
CDollar is modified in java technology in year 2013, 2015,2016.
CDollar is the combination of JAVA , C/C++, and Advanced OOPS.
it will only accept the shortest attractive syntax.
CDollar first name is "OLIVE Technology" which represents OLIVE TREE . Olive Technology
is renamed as CDOLLAR.
Note: a) The Meaning of CDollar is combination of C++ and JAVA OOPS
concepts.
b) CDollar version 1 and CDollar Version 2 is not good
c) CDollar version 3 contains a build compiler .cdollar.
where .cdollar has the features like java and C/C++.

SYNTAX-1 (used only for WEB - .cdollar)
------------------------------------------------------------
<CDollar>
<IMPORT>
<%
<! CDollar-.cdolar OOPS Logic and main functions !>
%>
?>

PRINT STATEMENT OF CDOLLAR .cdollar
------------------------------------------------
Print Statement of CDollar - .cdollar
-------------------------------------------------
Print.Println(String ,<DataTypes>);
where DataTypes is {int,char,String,Double,float)
This will print space followed by concatenation of String and
datatypes input when you apply \n.
This solves everytime when user wish to concat a String with
datatype every time.
simillary
Print.printf(String ,<DataTypes>);
This will be same to above Print statement but
it will not print space when you apply \n also.

Program-1.cdollar
-----------------
<CDollar>
<IMPORT>
<%
class Program1
{
public  Shared void  LIB( )
{
int i;
Print.Println("\nList of Technologies in year ","2016 ");
LL1 list = <NEW> LL1();
String i1="weew";
Print.Println("wilmix",i1);
Print.Println("Hiram is going","today");
Print.printf("Hiram Age is =","45 ");
Print.Println("Hiram is working ","in Abc Bank\n");
Print.Println(" \njemin","is going");
<TS> ar2 = <NEW> <TS>();
ar2.add("100");
ar2.add("22");
Print.printf("jeminjhjhjh",ar2.StringConvert());
Print.Println("no: 2/782 ,ds street,california-2322",ar2.StringConvert());
}
}
%>
?>
Notice what happens?
Compile and run the CDollar Program in bash shell using the
command
CDollarc Program1.cdollar
Output:
.
*************************************************************************************
********
Sun Sep 20 14:38:19 GMT+00:00 2015*CDollar: List of Technologies in year 2016 0 C 1
CDOLLAR 2 GDOLLAR 3 CHDOLLAR 4 JDOLLAR 5 JSTAR 6 JSAUCER
wilmix weewHiram is going todayHiram Age is = 45 Hiram is working in Abc Bank jemin is
goingjeminjhjhjh [100, 22]
no: 2/782 ,ds street,california-2322 [100, 22]
Error: <table bgcolor=green>OUTPUT=Compling Cdollar files
CDOLLAR VERSION 1.3 Copy Right 2015 all rights reserved
Created by Jemin Information Technology ,wilmix jemin Bad token: < on row 2 and column 1
Process failed during translation. no Errors in Cdollar program
Note:
----
To Compile and run the CDollar Program in bash shell using the
command
CDollarc filename.cdollar
or
CDRUN <filename.wl> to see the Output or Errors of Cdollar.
Output:
------
> Cdollar EVENORODD

Check Whether the Given No is ODD or EVEN : ?
5
ODD No is 5
WELDONE !
Note: Read.sreadln() Function is used to read data from the
console.....
-------
FAQS:
--------
Why CDollar (.C$) is simillar to JAVA OOPS concepts?
Since in futhure JSAUCER want to interact with
MYBATICS
Framework.

How CDollar is formed ? What are its Advantages Over Native language JAVA Programming?
-----------------------------------------------------------------------------------------------
CDollar is formed in C++ OOPS concepts..
JAVA borrowed C++ OOPS concepts but
CDollar borrowed C++ OOPS concepts and JAVA oops and it has
Attractive syntax ; Plus in-build functions
for Program and it is responsible for creating
libraries (.wl). JAVA has attained the Programming
standards, But CDollar attains combination of C Technology
and JAVA Technology advantages.
CDollar Generates .wl class files
but JAVA Generated .class files.
Cdollar Has Advanced OOPS than JAVA 1.8.

=========================================================
CDOLLAR ADVANCED CONCEPTS
=========================================================
CDOLLAR ADVANCED CONCEPTS
-------------------------------------
ADVANCED OOPS CONCEPTS
--------------------------------------------

Example -3:
------------
Write a Program to print two String and add String 100 to
ArrayList.and create a DataStructure for Linked List and Technologies for year 2016  is C, CDOLLAR ,GDOLLAR,CHDOLLAR, JDOLLAR,JSTAR, JSAUCER.
And add Those in Userdefined LinkedList. But you should not use
extends keyword to provide inheritance. but you should call the method of
other program without extending the class.

IS it Possible? IN JAVA?
NO

IS it Possible ? in CDollar?
Yes.

Program :abc.cdollar
-------------------
<CDollar>
<IMPORT>
<%
class LL1
{
private LL1 nextNode = null;
private String datum = null;
public LL1()
{
LL1 list = <NEW> LL1("0 C");
list.add("1 CDOLLAR");
list.add("2 GDOLLAR");
list.add("3 CHDOLLAR");
list.add("4 JDOLLAR");
list.add("5 JSTAR");
list.add("6 JSAUCER");
for (int i = 0; i NOT= list.size(); i = i + 1)
{
Print.Println("",list.get(i).StringConvert());
}
}
public LL1(String datum)
{
<SUPER>();
<IS>.datum = datum;
}
public void add(String datum)
{
if (nextNode NOT= null)
{
nextNode.add(datum);
return;
}
nextNode = <NEW> LL1(datum);
}
public String get(int i)
{
if (i == 0)
return datum;
return nextNode.get(i - 1);
}
public int size()
{
if (nextNode == null)
return 1;
return nextNode.size() + 1;
}
}
class abc
{
public  Shared void  LIB( )
{
int i;
Print.Println("\nList of Technologies in year ","2016 ");
LL1 list = <NEW> LL1();
String i1="weew";
Print.Println("wilmix",i1);
Print.Println(" \njemin","is going");
<AList> ar2 = <NEW> <AList>();
ar2.add("100");
Main m =<NEW> Main();
m.main();
Print.Println("jeminjhjhjh",ar2.StringConvert());
}
}
%>
?>
Note : LinkedList1 is the unwanted keyword
-------
so cdollar did not accept it.
What will be the Output when you run using ?
>CDollarc abc.cdollar
Output:
------
Compiling ....
*************************************************************************************
********
Sun Sep 20 14:46:18 GMT+00:00 2015*CDollar: List of Technologies in year 2016
0 C 1 CDOLLAR 2 GDOLLAR 3 CHDOLLAR 4 JDOLLAR 5 JSTAR 6 JSAUCERwilmix weew jemin is goingList
of Technologies in year 2016
0 C 1 CDOLLAR 2 GDOLLAR 3 CHDOLLAR 4 JDOLLAR 5 JSTAR 6 JSAUCERjeminjhjhjh [100, 22]
Error: <table bgcolor=green>OUTPUT=Compling Cdollar filesCDOLLAR VERSION 1.3 Copy
Right 2015 all rights reserved
Created by Jemin Information Technology ,wilmix jemin Bad token: < on row 2 and column 1
Process failed during translation. no Errors in Cdollar program
Example-4:
-----------
Write a Program to add 1 lakh Natural integers using arraylist
and add the arraylist objects to CDollarArrays
what happens when you compile and execute the given the below program?

SYNTAX for CDollarArrays:
--------------------------------------
CDollarArrays list1 = new CDollarArrays(string);
to add any collection objects to array use
add (String) functions and to Display those
objects use list1.Display();
Any class that use CDollarArrays you should extends Array in class...
Program2:
---------
<CDollar>
<IMPORT>
<%
public class Program2 <--- CDollarArrays
{
public  Shared void  LIB( )

{
<AList> ar= <NEW> <AList> ();
for (int i=0;i<=100000;i++)
ar.add(i);
CDollarArrays list1 = <NEW> CDollarArrays("ANIMALS ");
list1.add("1 horse");
list1.add("2 pig");
list1.add("3 cow");
list1.add("4 goat");
list1.add("5 chicken");
list1.add("6 ostrich");
list1.add(ar.StringConvert());
list1.Display();
}
}
%>
?>
What will be the Output when you run using ?

CDollarc Program2.cdollar

Ans: It store other collection objects and stores huge amount of data.

TREEOFARRAY
---------------------
Write a Program to add 1 lakh Natural integers incremented by 10 using arraylist
and add the arraylist objects to TreeOfARRAY
what happens when you compile and execute the given the below program?

SYNTAX for TreeofArray:
--------------------------------------
TreeArray <name> = new TreeArray(String);
<name>.add(elements);
where elements may be string or collections....

Program: Tree.cdollar
--------------
<CDollar>
<IMPORT>
<%
public class Tree
{
public  Shared void  LIB( )
{
TreeArray root = <NEW> TreeArray("SNO");
<AList> ar= <NEW> <AList>();
for (int i=0;i<=100000;i+=10)
ar.add(i);
for (int i = 0; i NOT= 10; i = i + 1)
{
root.add("item "+ ++ i);
}
root.add(ar.StringConvert());
//print the tree's size and contents
Print.Println( "\n\n",root.size() );
root.printTree();
}
}
%>
?>
What will be the Output when you run using ?
CDollarc Tree.cdollar
Ans: It store other collection objects and stores huge amount of data
in tree format.


LISTOFARRAY
---------------------
Write a Program to add 1000 Natural integers using arraylist
and add the arraylist objects to LISTOfARRAY
what happens when you compile and execute the given the below program?

SYNTAX for List of Array:
--------------------------------------
LArray <name> = new LArray(string);
<name>.add(elements);
The elements may be string or collection elements.
Program : LArray1s.cdollar
---------------------------
<CDollar>
<IMPORT>
<%
public class LArray1s
{
public  Shared void  LIB( )
{
LArray root = <NEW> LArray("root");
<AList> ar= <NEW> <AList>();
for (int i=0;i<=1000;i++)
ar.add(i);
root.add("wilmix");
root.add("jemin");
root.add("shalom");
root.add("1010");
root.add("101");
root.add("201");
root.add(ar.StringConvert());
root.add("100000000");
//print the tree's size and contents
Print.Println( "\n\n",root.size() );
root.printTree();
}
}
%>
?>

What will be the Output when you run using ?
 CDollarc LArray1s.cdollar

Ans: It store other collection objects and stores huge amount of data
in tree format.
and sorts the elements in descending order and allow to insert the
element in to middle
of list. This means act like combination of Set and Linked List , and Tree....






=========================================================

 MISC ,Fundametals of CDollar, Keywords,Operators,loops,Datatypes,Inner class, OOPS concepts of Cdollar ,and collections
=========================================================

CDOLLAR OUTPUT STATEMENT
----------------------------------------------
CDollar.out.println(" "+" ");
It is used for printing the output followed by line.
We had to add + operator to concatenate the outputs.....
String
------------
String is represented by <Str> notation.
a) <Str> <strname> = new <Str> ();
This statement is used to create an object...
b) <Str> <strname> = value;
But this Statement will not create an object...
but it stores the value...
the differences between
a) if ( s1==s2)
== means it is used to compare the values...
b) if s1.EQ(s2)
EQ means EQUALS is used to compare objects..

CDOLLAR COLLECTIONS
------------------------------------
Why we use collections in our software development?
Because for various projects we will use various kinds of
datastructures that's why collections are focused.

Q: What are the Important concepts of Software Development?

ARRAYLIST
----------------
SYNTAX:
------------
<AList> <Type> arraylistobjectname = new <AList><Type>
But type may be Object, int, Double,String,etc.
Why we focus Arraylist ?
Since ArrayList involves Powerful insertion and search mechanism when
compared to array.
So we focus it.
Some built in functions available in ArrayList they are add and remove.
syntax : arraylistobjectname.add(<datatype>);
syntax: arraylistobjectname.remove(<datatype>);
How did you iterate the ArrayList?
<WR> syntax means Iterator; this is the shortest syntax of Iterator.
<WR> iteratorname = <CollectionOBJECT>.record();

LinkedList
----------
<LList> <Type> arraylistobjectname <NEW> <LList><Type>
But type may be Object, int, Double,String,etc.
As according to collection concepts , built in functions are Designed for
LinkedList they are add and remove.
syntax : Linkedlistobjectname.add(<datatype>);
syntax: Linkedlistobjectname.remove(<datatype>);
syntax : Linkedlistobjectname.addFirst(<datatype>);
syntax: Linkedlistobjectname.removeFirst(<datatype>);
syntax : Linkedlistobjectname.addLast(<datatype>);
syntax: Linkedlistobjectname.removeLast(<datatype>);
Actually when you study about Datastructures of LinkedList
and here we Designed the LinkedList using the LinkedList code
as mentioned in above that is LinkedList.c$. And add more functions...
and we use CDollar Generics...
What is the function of LinkedList? Why we use LinkedList?
In ArrayList You can't insert element in to the middle
or first or last so LinkedList is focused....
LinkedList is a Good example of Train....

VECTOR
------------
Vector also has the same Datastructures of ArrayList;
but why we focus? . So vector is simillar to Arraylist.
So we can mention in short notation as VList.
but Vector is synchronized and ArrayList is not Synchronized.
Vector use Enumerator and Iterator but ArrayList use only Iterator.
<VList> <VectorObject> = <NEW> <VList> ();
<VectorObject>.addE(elements);
but vector used add functions
<VectorObject>.first(); => Represent First Element...
<VectorObject>.last(); => Represent Last Element...
<VectorObject>.removeAll(elements); => It is used to remove all elements..
<VectorObject>.removeAt(elements); => remove at Particular position
<VectorObject>.remove(object); => remove the first occurance of the given element
<VectorObject>.remove(index); => Remove by Index or position.

OOPS in CDOLLAR
------------------------------
A) INHERITANCE NOT USING EXTENDS METHOD...

C.cdollar
-------------
<CDollar>
<IMPORT>
<%
class A
{
public A() { Print.Println("A's called","n"); }
}
class B
{
public B() { Print.Println("B's called","n"); }
}
class C
{
public C() { { Print.Println("C's called","n"); } }
public  Shared void  LIB( )
{
<NEW> A();
<NEW> B();
<NEW> C();
}
}
%>
?>
Output:
------
CDollar: A's called nB's called nC's called n
?>
What is the Output for that?
Tue Aug 18 08:14:53 GMT+00:00 2015*CDollar: A's constructor called nB's constructor called nC's
constructor called nError: <table bgcolor=green>OUTPUT=Compling Cdollar filesCDOLLAR
VERSION 1.3 Copy Right 2015 all rights reservedCreated by Jemin Information
Technology ,wilmix jemin Bad token: < on row 1 and column 1Process failed during translation. no
Errors in Cdollar program

B) POLYMORPHISM in CDOLLAR
-----------------------------------------------
What is polymorphism?
It is Means action on method to do different things
based on the object that is action upon.
Example:
-------------
Write a Program to compute Rectangle Area and Triangle area
using Polymorphism.
Geometry.cdollar
----------------------------
<CDollar>
<IMPORT>
<%
class Polygon {
Shared int width, height;
public Shared int set_values (int a, int b)
{ width=a; height=b; return(0); }
}
class Rectangle <--- Polygon {
public int area()
{ return width*height; }
}
class Triangle <--- Polygon {
public int area()
{ return width*height/2; }
}
class Geome<TRY>{
public  Shared void  LIB( ) {
Rectangle rect = <NEW> Rectangle();
Triangle trgl= <NEW> Triangle();
int t= Polygon.set_values (4,5) * Polygon.set_values (4,5);
Print.Println( "Rect area=",rect.area());
Print.Println( "Triange Area=",trgl.area());
}
}
%>
?>
What will be the Output?
Tue Aug 18 07:45:46 GMT+00:00 2015*CDollar: Rect area= 20Triange Area= 10
CAN CDOLLAR Solves diamond Problem in multiple Inheritance?
Yes
C) Write a Progam to List Faculty , students using Diamond method in CDOLLAR
:-
Note: Without Extends methods its calls methods and value when new ()
is intialized.
This is the Major Advantage of Cdollar over native programming languages
like JAVA.
Program: TA.cdollar
--------------
<CDollar>
<IMPORT>
<%
class Person {
// Data members of person
Person(){}
public Person(int x) { Print.Println("Person::Person(int ) called",x); }
}
class Faculty {
public Faculty(int x)
{
<NEW> Person(x);
Print.Println("Faculty::Faculty(int ) called",x);
}
}
class Student {
// data members of Student
public Student(int x) {
<NEW> Person(x);
Print.Println("Student::Student(int ) called", x);
}
}
class TA {
TA(int x) {
<NEW> Faculty(x);
<NEW> Student(x);
Print.Println("TA::TA(int ) called",x);
}
public  Shared void  LIB( )
{
<NEW> TA(30);
}
}
%>
?>
What will be the output ?

Tue Aug 18 07:59:57 GMT+00:00 2015*CDollar: Person::Person(int ) called 30Faculty::Faculty(int ) called
30Person::Person(int ) called 30Student::Student(int ) called 30TA::TA(int ) called 30Error: <table
bgcolor=green>OUTPUT=Compling Cdollar filesCDOLLAR VERSION 1.3 Copy Right 2015 all
rights reservedCreated by Jemin Information Technology ,wilmix jemin Bad token: < on row
1 and column 1Process failed during translation. no Errors in Cdollar program

How to run this program?
CDollarc <Filename.cdollar>

C) ABSTRACT CLASS

What did you meant by Abstract class?

Abstract class defines an Abstract concept which can't
be instanated using new Operator().
Where compare to multiple Inheritance it has an implementation
where multiple Inheritance cannot have.

<CDollar>
<IMPORT>
<%
abstract class Abc51
{
abstract void display();
}
public class Abc5 <--- Abc51
{
Shared void display()
{
Print.Println("Wilmix","jemin");
}
public  Shared void  LIB( )
{
display();
}
}
%>
?>
Output:
-------
No output
Note:
------
It will display errors in wl file.
Errors:[Abc5.CDollar:27: display() in Abc5 cannot override display() in Abc51; overriding method is
static]Errors:[ static void display()]Errors:[ ^]Errors:[1 error]
SO when you remove static in display method()
and call display method() in CDollar Main Program
What happens?
Abc5.cdollar: 35: non-static method display() cannot be referenced from a static context
display();
^
1 error
This means it does not allow the Object to be created ......
and it doesnot allow static methods in abstract class.
=========================================================================
More about COLLECTIONS
---------------------------------------------
SET
------
So Set is represented in Cdollar as <S>
Syntax:
-----------
<S> Objectname = new <S>();
Difference between Set and List?
List allow duplicates but Set did not allow duplicates...
Set did not allow insertion at middle.
For listing the elements in Ascending or descending order
we had to use TreeSet.
Treeset
------------
Treeset represent a collection that uses Tree datastructure for storage
Items in the collections are stored in Ascending or descending order.
<TS> objectname = new <TS>();
objectname.add(elements);
Write a Cdollar Program about Treeset?
remaining things Developer should fill it.
public  Shared void  LIB( )
{
<AList> ar= <NEW> <AList>();
ar.add("1123");
ar.add("211");
ar.add("31");
ar.add("4");
ar.add("100");
<SORTINT>( ar,"ASC");
<SORTINT>( ar,"DESC");
<AList> ar1= <NEW> <AList>();
ar1.add("rahul");
ar1.add("wilmix");
ar1.add("dion");
ar1.add("shiyam");
ar1.add("priya");
ar1.add("abraham");
<SORTSTRING>( ar1,"ASC");
<SORTSTRING>( ar1,"DESC");
}
Output:
------
Order=ASC[4][31][100][211][1123]
*******************************
Order=DESC[1123][211][100][31][4]
*******************************
Order=ASC[abraham][dion][priya][rahul][shiyam][wilmix]
*******************************
Order=DESC[wilmix][shiyam][rahul][priya][dion][abraham]
Operators conditions and loops
--------------------------------------------------
Operators
---------
+ => ADD
++=> Increment
- => Substract
--=> Substract
* => Mulitply
/ = Division
~ => bitwise unary not operator
NOT (!) => flips true values to false and false values to true.
>>, >>>, and << => IT is used to shift all the bits of a number left
or right
a Specified number of places...
Other Operators
----------------
AND => And operator
OR => OR operator
?: => value =condition ? value1 : value2 (similar to if then else)
== => compare two values...
= => Assignment operators
EQ => Compare two objects
Relational Operators
--------------------
> >= => Greater than , Greater than equals.
< <= => Less than , Less than equal
NOTEQ => Equals and not equals
NotEQ simillar to !=
CONDITIONS
----------
IF Syntax:
------------
if <condition> statements;
IF then else Syntax:
----------------------
if <condition> statements else statements1
if <condition> statements1 else if condition1 statement2 .... and soon.
SWITCH Statements:
-------------------
switch (expression)
{
case value1 :
statement1;
[break]
................
case valuen:
statementn;
[break]
-----
default:
default_statement;
}
Explanation:
------------
If the expression is equals value1
statement1 will be executed.
if you use break it comes out of the loop
otherwise it continue to execute next statement.
The default value at the end is optional. It can be included if there are other values that can be held in
your variable but that you haven't checked for elsewhere in the switch statement.
THE WHILE LOOP
-----------------------------
while (<condition> )
{
< Statements block>
}
Note: if the condition is true the block get executed.
otherwise the loop will be continued.
THE DO --- WHILE LOOP
-----------------------------
do
{
< Statements block>
}
while( <conditon> )
Note: if the condition is true the block get executed.
and it is tested at the end of the loop, but not at the
beginning. The loop will be continued until it satisfies the condition.
biggest reason to be use the do - while loop is that
when you need the body of the loop to be run atleast once.
FOR LOOP
--------
for ( identifier=value; cond1; iterator operators)
{
< Block statements >
}
For -EACH Statement
----------------------
for ( variable : collection)
statement;
for eg)
If you add integers (1 to 3) to arraylist
and if you wish to copy and store it in an integer variable
so that you can print the values that is copied from
arraylist.
Then follow this method of for each statements...
for ( int a : ar)
{
CDollar.out.println("value="+a);
}
Output:
-----------
value=1
value =2
value =3
CONTINUE and Break
---------------------------------
Break means it break out of loop
and continue means
it will continue to execute the statements;
for eg)
Program :WHILE LOOP with continue and break if statement...
--------------------------------------------------------------------------
<CDollar>
<IMPORT>
<%
public class WHILE
{
public  Shared void  LIB( )
{
int a=0;
while (a <=10)
{
a++;
CDollar.out.println("value="+a);
if ( a==9) continue;
// if you remove this if --else statements it will print all the
values..
else break;
}
}
}
%>
?>
Output:
-------
Wed Aug 19 10:09:23 GMT+00:00 2015*
CDollar: value=1
Error: <table bgcolor=green>OUTPUT=Compling Cdollar filesCDOLLAR VERSION 1.3 Copy
Right 2015 all rights reservedCreated by Jemin Information Technology ,wilmix jemin
Bad token: < on row 2 and column 1Process failed during translation. no Errors in Cdollar .

DATATYPES and OVERLOADING and OVERRIDING CONCEPTS, INNER CLASS
---------------------------------------------------------------------------------------
DATATYPES of CDollar are
-------------------------------
int -> accept only int value
float -> accept float value=>eg) 1.5f
boolean => true or false
character => accept character value
byte -> 1 byte
short -> 2 bytes
long-> 8 bytes
double-> for eg) 1.2121233232E9 => Accept double value
ARRAY => It is used to store values and had fixed size.
ARRAY
-------
SYNTAX:
<Datatype> Arrayname ARRAY [index]
int a ARRAY[1000]; => has 1000 locations to store values...
for two dimension ARRAY
int a[100] ARRAY[100]=> 100 *100 => has 10000 locations to store values
OTHER KEYWORDS IN CDOLLAR
--------------------------------------------------
AND -> AND operator
NOT -> NOT operator
# -> NOTEQUALS
RUN -> Runnable used in thread
TH-> Thread
<EXE> -> Exception
Friends -> Frend function
INNER and OUTER CLASS
-----------------------------------------
Inner class are nested inside outer class even if the fields
declared as private members.
<CDollar>
<IMPORT>
<%
class Outer {
private int privInt = 10;
public void createInnerClass() {
Inner inClass = <NEW> Inner(); //creating innerclass object and calling method
access.
inClass.access();
}
class Inner { // Inner class
public void access() {
CDollar.out.println("The outer classs privInt is " + privInt);
}
}
}
%>
OVERLOADING AND OVERRIDING functions
-------------------------------------------
OVERLOADING
------------
A functions with same name but different signature is called
as Overloading concept.
public void display(int i , String j) {}
=> If you pass int and string values from main program it will call
this function.
ABC a = <NEW> ABC(10,"ewew");
public void display(int i, int j) {}
ABC a = <NEW> ABC(10,20);
=> If you pass int and int values it will call this function.
OVERRIDING
-----------
A function with same name and same signature
will cause overriding....
Overriding can be avoided by using super() keyword.
in another class.
<CDollar>
<IMPORT>
<%
class abc
{
void display(String s)
{
CDollar.out.println("We learn C , Dotnet ,and ,CDollar");
}
}
class abcd <--- abc
{
void display(String s)
{
<SUPER>(s); // if super keyword is added we had to pass arguments in
super keyword.
CDollar.out.println("We learn C , Dotnet ,and ,JDollar");
}
}
%>
Note: this will cause overriding
and it can be avoided by using super () keyword.

OTHER ATTRACTIVE SYMBOLS in CDOLLAR
-------------------------------------------
--> => implements
<-- => extends
MISC
-----
Program -MISC
-----------------------
<CDollar>
<IMPORT>
<%
// Advanced concepts : Here Friends is a helper function used in other classes
friends toy
{
public void display();
}
// friends will act like friend function in C++.
class concat1 --> toy
//---> indicates implements toy
{
public void display()
{
CDollar.out.println("CDollar is going to be finished");
}
}
public class concat
{
Shared int counter=4;
//Shared means static and which can be accessed over all the objects of
variables.
//<EXE> means throws Exception
// <S> means set
//<WR> indicates iterator
//<SBD> means string builder
//<SB> is String Buffer
// Differences is StringBuffer is Synchronized and
//and String Builder is not Synchronized
//AND means && in JAVA
//NOT means ! in JAVA
//TH means Thread in CDollar
//int <Arrayname> Array [nooflocations] (ARRAY SYNTAX)
//addE means AddElements
public  Shared void  LIB( ) throws <EXE>
{
int i;
String i1="weew";
Print.Println("wilmix",i1);
Print.Println(" \njemin","is going");
<S> <Integer> ar2 = <NEW> <TS> <Integer> ();
ar2.add(100);
<WR> it = ar2.record();
while (it.<HAS>)
{
<OBJECT> el= it.next();
Print.Println("/n",el.StringConvert());
}
<SBD> sb = <NEW> <SBD>("weldone wilmix");
int a;
a=105;
if (( a >100) AND (a<=106))
CDollar.out.println("/n"+a);
if (a NOT= 0)
CDollar.out.println("/n"+a);
a+=2+counter;
if (a # 107)
CDollar.out.println("/n"+a);
TH t = <NEW> TH();
int a11[] <Array> int[100];
a11[0]=1000;
CDollar.out.println("/n"+a11[0]);
<VList> v = <NEW> <VList>();
v.addE(100);
CDollar.out.println("/n"+v.get(0));
v.removeAt(0);
v.addE(1001);
v.addE(1002);
CDollar.out.println("/n"+v.first());
// This is the program for writing program in random access file ;
//it means it can be randomly inserted and retrieved at any location */
//writing word in random accessfile
<RANDOMACCESSFILE> rf = <NEW> <RANDOMACCESSFILE>("concat.c$","rw");
rf.write("Hello World".getBytes());
rf.close();
rf.close();
concat1 obj = <NEW> concat1();
obj.display();
}
}
%>
?>
So What will be the Output?
OUTPUT:
--------
Wed Aug 19 17:33:47 GMT+00:00 2015*
CDollar: wilmix weew jemin is going/n 100/n105/n105/n111/n1000/n100/n1001
CDollar is going to be finished
Error: <table bgcolor=green>
OUTPUT=Compling Cdollar files
CDOLLAR VERSION 1.3 Copy Right 2015 all rights reserved
Created by Jemin Information Technology ,wilmix jemin
Bad token: < on row 2 and column 1Process failed during translation.
no Errors in Cdollar program


Advanced Topics in FILE
-----------------------------
<BUFFINPUTSTREAM> =>you can use <MARK> and <RESET> keyword
to move backward in a buffered input stream.
<DOUTPUTSTREAM> =>
which can be used to write the stream or to do other operations on the stream.
IT USES <WRITEBYTES> TO Write into file.
<DINPUTSTREAM > => USED TO READ STRING FROM
THE FILE. It Uses <READBYTES> TO READ FROM A FILE.
<BREADER> =>Buffered reader uses <READLINE> to read a line from a
file.
<BWRITER> => Buffered writer uses <WRITELINE> to write a line from a
file.
<INPUTREADER> =>
The InputReader is intended to wrap an InputStream, thereby turning the byte based input stream into a
character based Reader.
<FILE> => used fort creating reading ,Appending, and writing string to a file.
Note: Character files are read and written using <FileWriter> and <FileReader>. Writing Streams of
character is best suited using FileWriter.
FileReader
----------
FileReader assumes that default character encoding and default byte-buffer size are appropriate.
FileReader reads character stream.
<FILESREADER>
FileWriter
----------
FileWriter assumes that default character encoding and default byte-buffer size are appropriate.
<FILESWRITER>
OUTPUTWRITER
<OUTPUTWRITER>
The OutputWriter is intended to wrap an OutputStream, thereby turning the byte based output stream
into a character based Writer.
Better than all this random Access file is the best use....
So file concepts are over. SO we ask developers to concenterate on
RandomAccess file....
OTHER COLLECTIONS CONCEPTS
---------------------------------------------------
<M> => map MEANS IT CONTAINS KEYS AND VALUE PAIRS...
HashSet
-------------
SYNTAX:
<HSET> <hashsetname> = <NEW> <HSET>();
HASHMAP
----------------
SYNTAX:
<HMAP> <HASHMAPNAME> = <NEW> <HMAP>();
<HASHMAPNAME>.PUT(key,valuepairs);
<HASHMAPNAME>.GETKEY(index);
<HMAP> mp = <NEW> <HMAP>();
mp .PUT(1, 234);
CDollar.out.println(""+mp.GETKEY(1));
HASHTABLE
----------------
SYNTAX:
<HTABLE> <HASHTABLENAME> = <NEW> <HTABLE>();
<HASHTABLENAME>.PUT(key,valuepairs);
<HASHTABLENAME>.GETKEY(index);
<HTABLE> mp = <NEW> <HTABLE>();
mp.PUT(1, 234);
CDollar.out.println(""+mp.GETKEY(0));
// This elements can be retrieved by using GETKEY().
note: hash determines a order in which elements are
stored in the hash; SO it will display according
to hash stored order.
ADVANCED CONCEPTS of CDOLLAR
----------------------------------------------------------
GENRIC STACK
-----------------------------
<GS> (we will see later)
ITERATOR
----------------
Iterator iterate about collection
in the forward direction and not in backward direction.
and it will iterate record wise from the List or collection.
<WR> it = collectionobj.record();
where collection obj may be list,arraylsit, and so on.
for EG)
<WR> it = ar.record(); //iterate arraylist.
while(it.<HAS>) // if it has more elements from arraylist
{
<OBJECT> el = it.<NEXT>;
//<OBJECT> is the object..
//<NEXT> is used to list next element from the collection
CDollar.out.println(" data= "+el);
//print the elements
}
Listiterator:
-------------
Normally Iterator will not move backward directions
by using iterator. It can be done by using Listiterator.
<LR> <listiterateobject> = Object.<LISTLR>();
eg)
<LR> it1 = ar.<LISTLR>; // iterate the arraylist in backward direction
if you use <PREVIOUS> keyword
while(it1.<HASP>) // if the iterator has more elements
{
<OBJECT> el1 = it1.<PREVIOUS>;
//move to previous record from arraylist
CDollar.out.println(" data1= "+el1);
//print the object
}
ARRAYSSORT
---------------------
<A>.<SORT>(arrayname);
SO if you want to sort an array you
must use the keyword <A>.<SORT>(ar);
That means the give array is sorted in ascending order and
store it in array
ARRAYBINARYSEARCH
-----------------
<A>.<BinarySearch>(arrayname,position)
This will search the array in binarysearch wise...
according to the given position.
MISC-EXAMPLE-2
--------------------------
<CDollar>
<IMPORT>
//implements thread
<%
abstract class misc <--- TH
{
// if variable declared as volatile means Synchronization happens
// at the variable level
// If the variable is declared as Transient
//means transient state is not saved. why we declared a Transient
//variable since it can used in the main program.
// <------- or ------> this means closing or hiding unwanted statements
// <DATE > means DATE
<VOLATILE> int v1;
Shared <TRANS> int v;
~
{
CDollar.out.println("object is deleted");
}
public int getnum1()
{
return(v1);
}
Shared int s3;
//simillar to operator overloading in c++.
public Shared void operator *(int s1 ,int s2)
{
s3=s1 * s2;
CDollar.out.println(""+s3);
}
public  Shared void  LIB( ) throws <EXE>
{
int a[] <Array> int[1000];
operator *(10,10);
operator *(200,10000);
<AList> ar = <NEW> <AList>();
for(int i=999;i>=0;i--)
{
a[i]=i;
ar.add(i);
}
<A>.<SORT>(a);
for(int i=0;i<=999;i++)
CDollar.out.println(" "+i);
CDollar.out.println(" "+<A>.<BinarySearch>(a,-5));
<WR> it = ar.record();
while(it.<HAS>)
{
<OBJECT> el = it.<NEXT>;
CDollar.out.println(" data= "+el);
}
<LR> it1 = ar.<LISTLR>;
while(it1.<HASP>)
{
<OBJECT> el1 = it1.<PREVIOUS>;
CDollar.out.println(" data1= "+el1);
}
<------
while (es.<HASEMORE>)
{
<OBJECT> el11 = es.<NEXTEL>;
CDollar.out.println(" data1= "+el1);
}
------>
<DATE> d2 = <NEW> <DATE>();
// print the month of the date
//print the year
//print the hours
//print the seconds
CDollar.out.println("month="+<Month>);
CDollar.out.println("Year="+<Y>);
CDollar.out.println("Hour="+<H>);
CDollar.out.println("Sec="+<SEC>);
//<VOLATILE> int v1;
//<TRANS> int v;
// Transient variable is assigned a value 20
v=20;
// Serialization
// Serialization means object stream is
//convert to stream of bytes we can save the object in
//harddisk and sent it across the n/w.
//fileoutputstream
<FOUTPUTSTREAM> os1 = <NEW> <FOUTPUTSTREAM>("out1.txt");
<OOUTPUTSTREAM> d = <NEW> <OOUTPUTSTREAM>(os1);
//object outputstream is used to write an object
///write an object
//write an arraylist object.
//and convert to serializable format.
d.<WRITEOBJ>(v);
d.<WRITEOBJ>(ar);
// read contents form the file
// objectinpustream to read the object...
//Objectread is used to read an object
//used to display the contents from the file in the deserialible format.
// ie, the format the user can read....
<FINPUTSTREAM> osd = <NEW> <FINPUTSTREAM>("out1.txt");
<OINPUTSTREAM> br = <NEW> <OINPUTSTREAM>(osd);
<OBJECT> ar7 = br.<OBJECTREAD>;
CDollar.out.println(""+ar7);
<STACK> s= <NEW> <STACK>();
s.<PUSH>(100);
s.<PUSH>(2000);
s.<POP>;
// push 100,2000 and pop last element 2000 and print it
CDollar.out.println(""+s);
<PRIORITYQUEUE> q = <NEW> <PRIORITYQUEUE>();
q.add(1000);
q.add(544);
q.add(66);
q.add(667888);
//add some elements to priority queue and print it
CDollar.out.println(""+q);
}
}
%>
?>
Exception and ERROR
-----------------------------------
Exception is a abnormal condition that arise during
the code sequence at run time.
What are the two Types of Exception?
Checked and Unchecked Exception.
Exception that arise during the run time are called as
Unchecked exception.
Thrown exception are refer to the checked exception.
Unchecked Exception
--------------------
<Arithmetic> -> Arithmetic exception
<ArrayIndex> -> ArrayIndex outof bound exception
<ArrayStore> -> Assignment to an array of an incompactible type.
<IndexOut> -> Index out of boud exception
<NegativeArraySize> -> Array Created with a negative array size.
<NullPointer> -> Null pointer exception
<NumberFormat> -> invalid conversion of string to numeric format.
typing or giving data string as input in integer datatype.
<SecurityException> -> Attempt to violate security
<StringIndex> ->Attempt to acess index ouside the bounds of a string.
Checked Exception
-----------------
<ClassNotFound> -.> class not found
<CloneNotFound>-> Clone keyword is absent
<IllegalAcess> -> Access to a class is denied.
<Instanation>-> Attempt to create an object of abstract class or friendly functions
<Interrupted>=> One thread has interrupted by another thread.
<NoSuchField> => A request field doesnot exist
<NoSuchMethod>=> Request emthod doesnot exist.
<TRY> -> try in C/JAVA
<CATCH> -> catch in c/java
<Finally> -> final in c/java
SYNTAX:
-------------
<TRY>
{
< Executable good statements>
}
<CATCH> (<EXE> e)
{
CDollar.out.println(""+e);
}
<Finally>
{
<Final block statements>
}
Explanation:
-------------------
When ever the Exception is true statements inside a try
block is executed; otherwise
statements inside a catch block is executed.
Exception occurs or not
final block get executed..
FINAL in CDOLLAR
--------------------------
UnShared keyword means final in CDollar
eg)
UnShared int i=9;
// if a variable is declared as final
that value can't be changed.
eg)
UnShared class abc
{
.......
}
if the class is declared as UnShared it can't
be overridden.
so if the method is declared as UnShared
such method can't be overriden by another class method.
GARBAGE COLLECTION
-------------------
<RECYCLE> => Garbage colection
eg) if you allocate elements a=9;
but doesnot use in the program so such object
are garbage collected by using <RECYCLE> keyword.

THREADS
--------------
A thread is a path of execution that run on CPU
and process is a collection of thread that share a same virtual
memory.

SIMPLE THREAD
----------------------------
<CDollar>
<IMPORT>
<%
public class threads1 <--- TH
{
public <Str> str;
public void <RUN>
{
for (int i=0;i<=10;i++)
CDollar.out.println(""+str);
}
public  Shared void  LIB( ) throws <EXE>
{
threads1 t = <NEW> threads1();
t.str = "thread1";
t.<START>; //start first thread
threads1 t1 = <NEW> threads1();
t1.str = "thread2";
t1.<START>; // start second thread.
//here after the thread1 get executed thread 2 is executed....
}
}
%>
?>
Output:
Thu Aug 20 11:12:44 GMT+00:00 2015*CDollar:
thread1thread1thread1thread1thread1thread1thread1thread1thread1thread1thread1thread2thread2th
read2thread2thread2thread2thread2thread2thread2thread2thread2Error: <table
bgcolor=green>OUTPUT=Compling Cdollar filesCDOLLAR VERSION 1.3 Copy Right 2015 all
rights reservedCreated by Jemin Information Technology ,wilmix jemin Bad token: < on row
2 and column 1Process failed during translation. no Errors in Cdollar program
<table bgcolor=green>
OUTPUT=
Compling Gdollar files
CDOLLAR VERSION 1.3
Copy Right 2015 all rights reserved
Created by Jemin Information Technology ,wilmix jemin
Bad token: < on row 2 and column 1
Process failed during translation.
no Errors in Cdollar
SYNCHRONIZED:
------------
If multiple clients want to access the shared resource
synchronization provide the way for the multiple clients
not for the specific one.
BIG Program for Synchronization
----------------------------------
<CDollar>
<IMPORT>
<%
class threads
{
public  Shared void  LIB( )
{
My thread1 = <NEW> My("thread1: ");
My thread2 = <NEW> My("thread2: ");
thread1.<START>;
thread2.<START>;
boolean thread1IsAlive = true;
boolean thread2IsAlive = true;
do {
if (thread1IsAlive AND NOTthread1.isAlive()) {
thread1IsAlive = false;
CDollar.out.println("MY DOG 1 is dead.");
}
if (thread2IsAlive AND NOTthread2.isAlive()) {
thread2IsAlive = false;
CDollar.out.println("MY DOG 2 is dead.");
}
} while(thread1IsAlive || thread2IsAlive);
}
}
class My <--- TH
{
Shared <Str> message[] ={ "CDollar", "is", "combination", "of", "JAVA", "and c"};
public My(<Str> id)
{
<SUPER>(id);
}
public void <RUN>
{
SyncOut.displayList("welcome",message);
}
void randomWait()
{
<TRY> {
<SLEEP>((long)((300)));
} <CATCH> (<Interrupted><EXE> x) {
CDollar.out.println("Interrupted!");
}
}
}
class SyncOut
{
public Shared <Synchronized> void displayList(<Str> name,<Str> list[])
{
for(int i=0;i<list.length;++i) {
// TH means Thread
My t = (My) TH.currentTH();
t.randomWait();
CDollar.out.println(name+list[i]);
}
}
}
%>
?>
 CDollarc threads.cdollar
OUTPUT:
Sun Sep 20 22:04:45 GMT+00:00 2015*CDollar:
welcomeCDollarwelcomeCDollarwelcomeiswelcomeiswelcomecombinationwelcomecombinationwelcom
eofwelcomeofwelcomeJAVAwelcomeJAVAwelcomeand
cMY DOG 1 is dead.welcomeand cMY DOG 2 is dead
.Error: <table bgcolor=green>OUTPUT=Compling Cdollar filesCDOLLAR VERSION 1.3 Copy
Right 2015 all rights reserved
Created by Jemin Information Technology ,wilmix jemin Bad token: < on row 2 and column
1Process failed during translation.
no Errors in Cdollar program
WAIT
--------
It WAITS indefinitely for another thread of execution until it receives notify
or notify all message.
<WAIT>
NOTIFY AND NOTIFYALL
----------------------------------------
<NOTIFY> ->
The keyword process waits for a single thread waiting on a
object monitor.
ALL ->
The keyword process waits for a multiple thread waiting on a
object monitor.
JOIN
--------
join() method
This Process join with another thread after another thread finishes the
execution.
eg) Thread t1 => Wait for 100 seconds
and Thread t2 => will execute after Thread t1 complets the execution.
This is the meaning of join process in Thread.

CDOLLAR ADVANCED CONCEPTS
--------------------------------
STACK
---------
Stack means lastin first out.
A stack is a container of objects that are inserted and removed according to the last-in first-out (LIFO)
principle.
In the pushdown stacks only two operations are allowed: push the item into the stack, and pop the item
out of the stack.
<STACK> s= <NEW> <STACK>();
s.<PUSH>(100); // PUSH operator to push the elements into stack
s.<PUSH>(2000);
s.<POP>;
CDollar.out.println(""+s);
Output:
[100]
Priority Queue:
---------------------
Many applications require that we process items having keys in order, but not necessarily in full sorted
order and not necessarily all at once.
Often, we collect a set of items, then process the one with the largest key, then perhaps collect more
items, then process the one with the current largest key,
and so forth. An appropriate data type in such an environment supports two operations:
remove the maximum and insert. Such a data type is called a priority queue.
<PRIORITYQUEUE> q = <NEW> <PRIORITYQUEUE>();
q.add(1000);
q.add(544);
q.add(66);
q.add(667888);
CDollar.out.println(""+q);
Output:
-------
[66, 1000, 544, 667888]
Destructor:
----------
Destructor means object is going to be destroyed.
~
{
CDollar.out.println("object is deleted");
// this means object is going to be destroyed.
}
where ~ is the Destructor

Operator Overloading in CDollar
------------------------------------------------
This means we can overload the operators
like + - = / > < >= <=
Compare CompareTo
public Shared void operator *(int s1 ,int s2)
{
s3=s1 * s2;
CDollar.out.println(""+s3);
}
public  Shared void  LIB( )
{
operator *(10,10);
// You are passing * Multiply Operator in the main Program
operator *(200,10000);
}
GENERICS
---------------
GENRICS means which is used to Pass Type as argument as class
for example if you want to pass String , int, float datatypes at the
same time and if you use display method to display the value of any
datatype
so Generic is most useful in that case.
<CDollar>
<IMPORT>
<%
public class GEN<T>
{
T t;
T display(T t1)
{
t=t1;
return(t);
}
public  Shared void  LIB( )
{
GEN <Integer> i = <NEW> GEN<Integer> ();
CDollar.out.println(""+ i.display(10));
}
}
%>
?>



=================================================================
CDOLLAR STRUCTURES
-----------------------------------
CDollar structure is another user defined data type available in CDollar programming, which allows
you to combine data items of different kinds.
using the same memmory location. It also provide an efficient way of using the same
memory location for multi-purpose.
Thus CDollar Structures is Equivalent = C progamming Structures and union.
and it uses less memmory capacity than any Programming languages. IT is also
used to store collections, objecte ,etc.
IT is the most important datastructure implemented by wilmix jemin j.
He reduces the demerits of C Programming and
C child is CDollar. So CDollar has very beautiful and Advanced Concepts
than
any Programming Languages. And the Native Technology like JAVA
fails to do.
Program-1:
---------
<CDollar>
<IMPORT>
<%
class structeg // define a class
{
Shared int sno; Shared int m1,m2,m3;
Shared double avg=0.0;
structeg(int sno,int m1,int m2,int m3,double avg)
{
<IS>.sno=sno;
<IS>.m1=m1;
<IS>.m2=m2;
<IS>.m3=m3;
<IS>.avg=avg;
}
public  Shared void  LIB( )
{
sno=1;
m1=234;
m2=456;
m3=656;
avg=((m1+m2+m3)/3);
structeg s = <NEW> structeg(sno,m1,m2,m3,avg); // create an object of a classs
structeg s2 = <NEW> structeg(sno,m1,m2,m3,avg); // create an object of a classs
<STRUCTURE> <<OBJECT>> list = <NEW> <STRUCTURE> <<OBJECT>>(s);
list.add(s2);
//add the Objects to structures....
for (int i = 0; i NOT= list.size(); i = i + 1) //compute the size of structures
{
<OBJECT> el=list.ret(i);
structeg s1= (structeg)el;
//made class objects equals structure objects and cast using structure ....
CDollar.out.println("SNO= "+s1.sno);
CDollar.out.println(" m1="+s1.m1);
CDollar.out.println(" m2="+s1.m2);
CDollar.out.println(" m3="+s1.m3);
CDollar.out.println(" AVG="+s1.avg);
CDollar.out.println(" size="+list.size());
}
}
}
%>
?>
What will be the Output?
OUTPUT:
------------
Fri Aug 21 13:29:21 GMT+00:00 2015*CDollar:
SNO= 1 m1=234 m2=456 m3=656 AVG=448.0 size=2 SNO= 1 m1=234 m2=456 m3=656 AVG=448.0 size=2
ADVANTAGES:
--------------------
Billing programs, GUI, Record wise Search and Printing ,etc...














=========================================================
CDOLLAR GRAPHICS and NETWORKING
=========================================================

CDOLLAR GRAPHICS always focus on GWT Graphics and GUI. GWT
is a heavy weighted toolkit.
CDollar Graphics can be done by extending Graphics class.
This will create a frame for that.
GWT graphics can be drawn using <PAINT> method.
Program-1
----------
<CDollar>
<IMPORT>
<%
class abcde <--- Graphics
{
public  Shared void  LIB( )
{
abr a = <NEW> abr();
a.<SIZE>(500,700);
a.<FLOWLAYOUT>
a.<VISIBLE=TRUE>
}
Shared class abr <--- abcde
{
<PAINT> //c
for(int i=0; i<=600;i++)
{
<DRAWTEXT>("CHOOSEN CHOICE is",400,500);
<SETCOLOUR>(COLOR=red); //set color of oval
<OVAL>(10+i,10+i,50+i,50+i);
<FILLOVAL>(70+i,90+i,140+i,100+i);
<SETCOLOUR>(COLOR=blue); //set color of oval and rect
<OVAL>(190+i,10+i,90+i,30+i);
<RECT>(100+i,10+i,60+i,50+i);
<SETCOLOUR>(COLOR=cyan); //set color of rect
<FILLRECT>(100+i,10+i,60+i,50+i);
<ROUNDRECT>(190+i,10+i,60+i,50+i,15+i,15+i);
<SETCOLOUR>(COLOR=green);
<ARC>(10+i,20+i,150+i,190+i,160+i,60+i); //drow an arc
<FILLARC>(230+i,15+i,150+i,200+i,150+i,75+i);
if ( i== 300) i=i-1; //if i==300 decrement i by 1
}
}
}
}
%>
?>
Program-2:
----------
Draw a house using CDollar
============================

<CDollar>
<IMPORT>
<%
class HOUSE <--- Graphics
{
public  Shared void  LIB( )
{
houseparts a = <NEW> houseparts();
a.<SIZE>(500,700);
a.<FLOWLAYOUT>
a.<VISIBLE=TRUE>
}
Shared class houseparts <--- HOUSE
{
<PAINT>
{
background(g);
house (g);
roof1 (g);
roof2 (g);
windows (g);
framing (g);
extras (g);
text (g);
}
public void background(<DRAW> g)
{
<SET>Background (COLOR=white);
<SETCOLOUR>(COLOR=black);
<FILLOVAL> (15,35,170,55);
<FILLOVAL> (20,20,160,50);
<FILLOVAL> (350,50,170,55);
<FILLOVAL> (355,35,160,50);
<SETCOLOUR>(COLOR=cyan);
<FILLOVAL> (650,035,120,120);
<SETCOLOUR>(COLOR=green);
<ARC>(10,20,180,190,160,60);
<FILLARC>(230,15,150,200,150,75);
}
public void house (<DRAW> g)
{
<SETCOLOUR>(COLOR=yellow);
<FILLRECT> (100,250,400,200);
<FILLRECT> (499,320,200,130);
<SETCOLOUR>(COLOR=green);
<FILLRECT> (160,150,60,90);
<FILLRECT> (245,380,110,70);
<FILLRECT> (508,350,180,100);
<SETCOLOUR>(COLOR=yellow);
<FILLOVAL> (282,412,10,10);
<FILLOVAL> (307,412,10,10);
}
public void roof1 (<DRAW> g)
{
<SETCOLOUR>(COLOR=pink);
int x[] = {98,300,501};
int y[] = {250,130,250};
<FILLPOLYGON>(x,y,3);
}
public void roof2 (<DRAW> g)
{
<SETCOLOUR>(COLOR=orange);
int x[] = {499,499,700};
int y[] = {320,249,320};
<FILLPOLYGON>(x,y,3);
}
public void windows (<DRAW> g)
{
<SETCOLOUR>(COLOR=white);
<FILLOVAL>(521,350,68,31);
<FILLOVAL> (606,350,68,31);
<FILLRECT> (121,261,78,78);
<FILLRECT> (121,361,78,78);
<FILLRECT> (401,261,78,78);
<FILLRECT> (401,361,78,78);
<FILLRECT> (241,261,118,78);
<SETCOLOUR>(COLOR=white);
<FILLRECT> (125,265,70,70);
<FILLRECT> (125,365,70,70);
<FILLRECT>(405,265,70,70);
<FILLRECT> (405,365,70,70);
<FILLRECT> (245,265,110,70);
<FILLOVAL> (525,353,60,25);
<FILLOVAL> (610,353,60,25);
}
public void framing (<DRAW> g)
{
<SETCOLOUR>(COLOR=black);
<FILLRECT> (298,380,2,70);
<FILLRECT> (508,382,180,2);
<FILLRECT> (508,417,180,2);
<SETCOLOUR>(COLOR=white);
<FILLRECT> (157,265,5,70);
<FILLRECT> (157,365,5,70);
<FILLRECT> (437,265,5,70);
<FILLRECT> (438,365,5,70);
<FILLRECT> (297,265,5,70);
<FILLRECT> (125,298,70,5);
<FILLRECT> (125,398,70,5);
<FILLRECT> (405,298,70,5);
<FILLRECT> (405,398,70,5);
<FILLRECT> (245,298,110,5);
<FILLRECT> (245,375,110,5);
<FILLRECT> (240,375,5,75);
<FILLRECT> (352,375,5,75);
<FILLRECT> (508,345,180,5);
<FILLRECT> (503,345,5,105);
<FILLRECT> (688,345,5,105);
}
public void extras (<DRAW> g)
{
<SETCOLOUR>(COLOR=orange);
<FILLOVAL> (160,105,35,45);
<FILLOVAL> (170,95,35,45);
<FILLOVAL> (160,85,35,45);
<FILLOVAL> (170,35,35,45);
<FILLOVAL> (160,25,35,45);
<FILLOVAL> (170,15,35,45);
<SETCOLOUR>(COLOR=orange);
<FILLRECT> (508,450,180,150);
<FILLRECT> (245,450,107,50);
<FILLRECT> (274,500,50,40);
<FILLRECT> (274,520,250,45);
}
public void text (<DRAW> g)
{
<SETCOLOUR>(COLOR=orange);
<DRAWTEXT>("House portrait by: wilmix jemin",390,70);
}
}
PROGRAM-3
----------
if you select radio or listbox or combobox it should display items
in text box.
//Graphics using GWT and GWT components are heavy weighted
<CDollar>
<IMPORT>
<%
class GUI1 <--- IconImage --> <HEAR>
// <HEAR> is a Listener
{
Shared <RADIO> r <GWT=6>(); //declare a radio
Shared <TEXTFIELD> l3 <GWT=3> (); // declare a text box
Shared <CHECKBOX> l5 <GWT=5> ("YES",false,r); //declare a radio button
Shared <CHECKBOX> l51 <GWT=5> ("NO",false,r); //declare a radio button
Shared <LISTBOX> lb <GWT=7>();// declare a listbox
Shared <COMBOBOX> cb <GWT=8>();//declare a combo box
Shared <Str> s= "";
<ITEMSTATECHANGED> //if you choose checkbox or combox or listbox
{
if (ie.<ITEMSELECTABLE> == l5)
l3.<VALUE>("YES"); //set text value =yes
if (ie.<ITEMSELECTABLE> == l51)
l3.<VALUE>("NO"); //set text value =no
if (ie.<ITEMSELECTABLE> == cb)
l3.<VALUE>(((<COMBOBOX>) ie.<ITEMSELECTABLE>).<SELECTITEM>);
//set text value =combobox select item
if (ie.<ITEMSELECTABLE> == lb)
l3.<VALUE>(((<LISTBOX>) ie.<ITEMSELECTABLE>).<SELECTITEM>);
//set text value =lsit box select item
s=l3.<ASSIGN>(); //get textbox value and assign to s
}
public  Shared void  LIB( ) {
abrpaint g =<NEW> abrpaint();// <NEW> for creating object for class
<IMAGE>
//GUI1 g = <NEW> GUI1();
<LABEL> l1 <GWT=1> ("CDollar GUI Programming"); //creating instance of label
<BUTTON> l2 <GWT=2> ("CDollar GUI Programming"); //creating instance of button
//<TEXTFIELD> l3 <GWT=3> ();
<TEXTAREA> l4 <GWT=4> (12,40);//creating instance of textfield
//<CHECKBOX> l5 <GWT=5> ("Yes");
l5.<SOUND>(g);//add listener to radio button
//<CHECKBOX> l51 <GWT=5> ("NO");
l51.<SOUND>(g); //add listener to radio button
l3.<VALUE>("<THIS> is a textbox"); //set value of text field
l4.<APPEND>("Number of columns in this textarea: " + l4.<COLS>); //append text area
and display no of cols
//used to add components to the Graphics
g.add(l1);
g.add(l2);
g.add(l3);
g.add(l4);
g.add(l5);
g.add(l51);
//add some items to listbox
lb.add("CDOLLAR");
lb.add("JAVA");
lb.add("JDOLLAR");
lb.add("C");
lb.add("MAC");
g.add(lb);lb.<SOUND>(g); //add listener to listbox
//add items to combobox
cb.add("CDOLLAR");
cb.add("JAVA");
cb.add("JDOLLAR");
cb.add("C");
cb.add("MAC");
g.add(cb);cb.<SOUND>(g); //add listener to combobox
g.<SIZE>(500,700); //set size of graphics frame
g.<FLOWLAYOUT> //set flowlayout
g.<VISIBLE=TRUE> //set frame to be visible
}
Shared class abrpaint <--- GUI1
{
<PAINT> //call paintmethod
{
<DRAWTEXT>("CHOOSEN CHOICE is"+s,400,500); //draw string at coordinates 400,500
<RECT>(20,10,100,60); //drow a rect
}
}
}
%>
?>
CDOLLAR Networking
-------------------------------------
N/w are essential to our life. Intenet is born due to networking and
A method of Client -server communications
gives like a house - to house interaction.

CLIENT SERVER PROGRAM
--------------------------------

<CDollar>
<IMPORT>
<%
class CLIENTSERVER
{
public  Shared void  LIB( )
{
<CLIENT>("WILMIX","1099"); // Declare client and call client and pass hostname and port
<SERVER>("1099");//Declare server and server and pass portno
}
}
%>
?>
OUTPUT:
-------
Sat Aug 22 08:52:19 GMT+00:00 2015*CDollar: Connecting to WILMIX on port 1099Waiting for client on
port 1099...Socket timed out!


Let us consider a Program to print using WHILE LOOP
Program -1
----------
<CDollar>
<IMPORT>
<%
public class WHILE
{
public  Shared void  LIB( )
{
int a=0;
while (a <=10)
{
a++;
CDollar.out.println("value="+a);
}
}
}
%>
?>
Compilation:
CDollarc WHILE.cdollar
Output:
(note: at One time compilation you will get this output in windows platform)
********************************************************************
Tue Mar 01 1
3:30:08 IST 2016*JAS: Error:
***************************************************
******************************************
WHILE Tue Mar 01 13:30:09 IST 2016 CDollar:
Output: value=1value=2value=3value=4value=5value=6value=7value=8value=9value=10va
lue=11Error: value=1value=2value=3value=4value=5value=6value=7value=8value=9valu
e=10value=11
========================================
What is Pointers?

Variables that hold memory address are called pointers.
Why we mainly use Pointers?
Pointers reduces the length and complexity of the program,
They increase the execution speed.
It holds the memmory addres..
SYNTAX of CDollar Pointers:
---------------------------------
{*}<<DATATYPE>> <pointer-name> Pointer<<DATATYPE>>(intialvalue);
for eg)
<Str> s ="Life is beautiful";
{*}<<Str>> l Pointer<<Str>>(s);
The given above statement will store the string "Life is beautiful"
in Pointer name l;
Write a program to store the value in pointers
--------------------------------------------------------------
<CDollar>
<IMPORT>
<%
public class WHILE
{
public  Shared void  LIB( )
{
int a=0;
{*} l Pointer(0); //store value 0 in pointer name l
while (a <=10)
{
a++;
l.add(a); // add all the values in pointer
}
for (int i = 0; i NOT= l.size(); i = i + 1) // compute the size and perform for loop
{
<OBJECT> obj=l.get(i); // ge the value by index i
CDollar.out.println(" value="+obj+ " "); // print the value
CDollar.out.println(" ");
CDollar.out.println(" Address= "+l); // print the memory address..
}
}
}
%>
?>
Compile using this command: CDollarc WHILE.cdollar
OUTPUT:
------------
Array=1Compiling ....
*************************************************************************************
********
Tue Feb 09 19:37:22 GMT+00:00 2016*CDollar: value=0 Address= ptr@187aeca value=1
Address= ptr@187aeca value=2 Address= ptr@187aeca value=3 Address= ptr@187aeca
value=4 Address= ptr@187aeca value=5 Address= ptr@187aeca value=6
Address= ptr@187aeca value=7 Address= ptr@187aeca value=8 Address= ptr@187aeca
value=9 Address= ptr@187aeca value=10 Address= ptr@187aeca value=11
Address= ptr@187aeca
Note: We notice CDollar pointers stores the values at same memory location
is the greatest Advantage in CDollar Programming...
What will happen when you use CDollar pointer with ArrayofArray to the
WHILE.cdollar ->
CDOLLAR-Main( ) ....?
CDollarArrays list1 = <NEW> CDollarArray("THINGS ");
list1.add("1 mat");
list1.add("2 mouse");
list1.add("3 pen");
list1.add("4 coat");
list1.add("5 printer");
list1.add("6 laptop");
list1.Display();
for (int i1 = 0; i1 NOT= l.size()-1; i1 = i1 + 1)
{
<OBJECT> obj1=list1.get(i1);
CDollar.out.println(" value="+obj1.StringConvert()+ " ");
CDollar.out.println(" ");
}
OUTPUT:
Compiling ....
*************************************************************************************
********
Tue Feb 09 19:56:37 GMT+00:00 2016*CDollar: value=0 Address= ptr@187aeca value=1
Address= ptr@187aeca value=2 Address= ptr@187aeca value=3 Address= ptr@187aeca
value=4 Address= ptr@187aeca value=5 Address= ptr@187aeca value=6
Address= ptr@187aeca value=7 Address= ptr@187aeca value=8 Address= ptr@187aeca
value=9 Address= ptr@187aeca value=10 Address= ptr@187aeca value=11
Address= ptr@187aeca, , , , , , , [{ 1 mat }{ 2 mouse }{ 3 pen }{ 4 coat }{ 5 printer }{ 6 laptop } ]
value=ThreadINGS value=1 mat value=2 mouse value=3 pen value=4
coat value=5 printer value=6 laptop
Note: Again CDollar pointers stores the values at same memory location
is the greatest Advantage in CDollar Programming...
Write an example to exchange the Pointer values using functions?
-------------------------------------------------------------------------------
<CDollar>
<IMPORT>
<%
public class func
{
Shared int a=100; // make the variable as static
Shared {*} l1 Pointer(a); // declare l1 pointer and assign a value
Shared int b=10000;
Shared {*} l2 Pointer(b); // declare l2 pointer and assign a value
Shared {*} l3 Pointer(0); // declare l1 pointer and assign a initial value
public  Shared void  LIB( ) throws <EXE>
{
int a=0;
func.exchange(l1,l2); // pass the pointer object to exchange functions...
CDollar.out.println(""+ l1.get(0)+""+l2.get(0));
}
public Shared void exchange(<OBJECT> a,<OBJECT> b) // declare the parameters as
object
{
l3=l1; // assign l3 pointer = l1
// l3 pointer will point to l1 address
l1=l2; // assign l1 pointer = l2
l2=l3; /assign l2 pointer = l3
}
}
%>
?>
Output:
Tue Feb 09 20:20:40 GMT+00:00 2016*CDollar: 10000 100
Now let us see an example using CDollar Pointers with structures...?
-----------------------------------------------------------------------------------
<CDollar>
<IMPORT>
<%
// define a class
class p<STRUCTURE>eg
{
Shared int sno; Shared int m1,m2,m3;
Shared double avg=0.0;
p<STRUCTURE>eg(int sno,int m1,int m2,int m3,double avg)
{
<IS>.sno=sno;
<IS>.m1=m1;
<IS>.m2=m2;
<IS>.m3=m3;
<IS>.avg=avg;
}
public  Shared void  LIB( )
{
sno=11;
m1=234;
m2=456;
m3=656;
avg=((m1+m2+m3)/3);
//create a structure and pass the values as arguments
// to structures..
p<STRUCTURE>eg s = <NEW> p<STRUCTURE>eg(sno,m1,m2,m3,avg);
// create an object of a classs
<STRUCTURE> <<OBJECT>> list = <NEW> <STRUCTURE> <<OBJECT>>(s);
list.add(s);
//add the Objects to structures....
{*} l Pointer(0);
//compute the size of structures
for (int i = 0; i NOT= list.size()-1; i = i + 1)
{
<OBJECT> el=list.ret(i);
p<STRUCTURE>eg s1= (p<STRUCTURE>eg)el;
// add structure values to pointer
l.add(s1.sno);
l.add(s1.m1);
l.add(s1.m2);
l.add(s1.m3);
l.add(s1.avg);
}
for (int i = 0; i NOT= l.size()-1; i = i + 1)
{
CDollar.out.println("LIST= "+l.get(i)+" "); // print the values from pointer
}
}
}
%>
?>
OUTPUT:
Tue Feb 09 21:01:23 GMT+00:00 2016*CDollar: LIST= 0 LIST= 11 LIST= 234 LIST= 456 LIST= 656

CDOLLAR File Manipulation:
-----------------------------
C$ file Manipulation contains
Insert , Insertrows, retrieve functions ....
This shortcut functions are mostly used for filemanipulation....
Now let us see CDollar Program with Security and Filemanipulation?
<CDollar>
<IMPORT>=> Import CDollar default packages
import Securitydb.*; => importing cdollar security package.....
<%
public class WHILE
{
public  Shared void  LIB( ) throws <EXE>
{
int a=0;
{*} l Pointer(0); => Intialize the pointer to 0.
while (a <=10)
{
a++; //increment a value
l.add(a); //store the values in pointer
}
for (int i = 0; i NOT= l.size(); i = i + 1) // use l.size() to compute pointer size.
{
<OBJECT> obj=l.get(i); // get the value of pointer
CDollar.out.println(" value="+obj+ " "); // print the value
CDollar.out.println(" ");
CDollar.out.println(" Address= "+l); // print the address
CDollar.WDBA.Manipulation.InsertRows(obj.StringConvert(),"wil.txt"); //store the values in
// wil.txt
}
Array list1 = <NEW> Array("THINGS "); // use array of array
list1.add("1 mat");
list1.add("2 mouse");
list1.add("3 pen");
list1.add("4 coat");
list1.add("5 printer");
list1.add("6 laptop");
list1.Display();
CDollar.WDBA.Manipulation.insert(list1.get(1),"wil1.txt"); // store array of array objects in
//wil.txt , this will insert a file new if text is present in wil1.txt
//it will truncate he text and insert newly...
// insert function performs replace the text again
<AList> ar5 = <NEW> <AList>();
for (int i1 = 1; i1 NOT= list1.size()-1; i1 = i1 + 1)
{
<OBJECT> obj1=list1.get(i1);
CDollar.out.println(" value="+obj1.StringConvert()+ " ");
CDollar.out.println(" ");
CDollar.WDBA.Manipulation.InsertRows(obj1.StringConvert(),"wil.txt");
// Insertrows perform update and insert the text again
// for eg) if you insert using insertrows 'house is' in wil.txt and if you
insert using insertrows 'located at caifornia" in wil.txt
// so the text file contains only "house is located at california" string.
}
CDollar.out.println(" OUTPUT from file= "+CDollar.WDBA.Manipulation.retrieve("wil.txt"));
// retrieve from file wil.txt
CDollar.out.println(""+CDollar.WDBA.Manipulation.retrieve("wil1.txt"));
// retrieve from file wil1.txt
Secure.InsertSecure("wil.sdb", 0,"while","while",CDollar.WDBA.Manipulation.retrieve("wil1.txt"));
//store the text in wil.sb security file using security.InsertSecure
so the hackers or any users can't access it.
CDollar.out.println("Security file contents wil.sdb......");
Secure.SretreiveSecure("wil.sdb" ,0); //retrieve the contents from security file and print
it to the //console
}
}
%>
?>
OUTPUT:
-------
Mon Feb 15 10:51:27 GMT+00:00 2016*CDollar: value=0 Address= ptr@e48e1b value=1
Address= ptr@e48e1b value=2 Address= ptr@e48e1b value=3 Address= ptr@e48e1b
value=4 Address= ptr@e48e1b value=5 Address= ptr@e48e1b value=6
Address= ptr@e48e1b value=7 Address= ptr@e48e1b value=8 Address= ptr@e48e1b
value=9 Address= ptr@e48e1b value=10 Address= ptr@e48e1b value=11
Address= ptr@e48e1b, , , , , , , [{ 1 mat }{ 2 mouse }{ 3 pen }{ 4 coat }{ 5 printer }{ 6 laptop } ] value=1
mat value=2 mouse value=3 pen value=4 coat value=5 printer
OUTput from file= 012345678910111 mat2 mouse3 pen4 coat5 printer012345678910111 mat2
mouse3 pen4 coat5 printer012345678910111 mat2 mouse3 pen4 coat5 printer012345678910111 mat2
mouse3 pen4 coat5 printer012345678910111 mat2 mouse3 pen4 coat5 printer1 mat
Security file contents wil.sdb......
<tr><td>1 mat</td>
==============
BUCKET
-------
Bucket are used to store key,value data, and Generated Random number
where datatype may be string ,object ,etc.
SYNTAX:
----------
Bucket<DATATYPE> list = <NEW> Bucket<DATATYPE>(<DATATYPEVALUE>);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Advantages
----------
Using Bucket you can also Retrieve the values stored n position.
Searching and Insertion is fast than other DTS.
Random Indexing is possible.
eg) If you store a duplicate value such Random key will be different.
It also used to add many values.
EXTEND
------
Extend class is used in CDollar since to provide multiple inheritence
about 100000000 classes . Extends class also list values in methods and
constructor values.
Extend means a Bucket contains List of class and it is also
Behave like Bucket. So it is also one of the Advanced concepts in CDollar.
SYNTAX:
--------
EXTEND <<DATATYPE>> list11 = <NEW> EXTEND <<DATATYPE>> (STRING);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Advantages:
It is also used to add many values
Indexing is possible
Value can also be list by index and behave like bucket.
It list only the class value and object value.
It is stateless.
PIPE:
-----
PIPE is used to maintain stateful state.
It is used for DataFlow in a Program. We can also add the values,
Constructor values of one class and other class and display it.
It also list the values from the Bucket.
SYNTAX:
-------
Pipe <<DATATYPE>> list11 = <NEW> Pipe <<DATATYPE>> (STRING);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Why we Prefer CDollar for software Field?
Used in BILLS, Forms ,Reports,Charts, any software project , GRAPHICS to web etc.

=========================================================

CDOLLAR CODING STANDARDS AND ADVANTAGES OVER OTHER
PROGRAMMING LANGUAGES
=========================================================
Coding Standards of CDollar
------------------------------
<CDollar>
<IMPORT>
<%
%>
?>
Note : <% and %> is used to write class and it's logic.
ALL Program should Start with <CDollar> means starting of a Program and
scucceded by <IMPORT>
to load CDollar packages and ?> Means End of the Program.
HIDE Unwanted code
--------------------
<------ program code ------>
MAIN Program:
-------------
public  Shared void  LIB( ) indicates MAIN Program
otherwise it will not run the Program
STATIC BLOCK
-------------
Shared means Static keyword.
Shared will be executed first after that Main program will
be executed.
Shared
{
}
{} => This curly braces are mostly used.
SOME OPERATOR KEYWORDS
-------------------------
AND => && in java
NOT => !
# => !=
NEW Keyword
---------------
NEW is used to create an instance in memmory.
Always concenterate on important keyword not need to
memmorize at all.
DATATYPES:
-----------
int , char, double , float are ordinary keywords of oops
Programming language like C/JAVA/C#/CDollar.
STRUCTURES:
-----------
Always use Structure DATATYPE to store your data in objects form
so that it will reduce the storage allocation in memmory.
for one object it takes only 1 byte of memmory for structures.
RECYCLE:
-------
Always use RECYCLE to make the unwanted object to be garbage collected.
//
----
If you want to describe something about your functions
use // . Don't use it unnessary at any way.
Special Characters
--------------------
@,$%,^,[] are not allowed in the CDOLLLAR program
~
---
Use Destructor keyword to specify non CDollar resource deletion code to
be goes when you it..
Other Things
-------------
for loop , if statements, while loop, do while ,
for each, Switch statements, AutoBoxing , Generics , etc
are same.
Did CDollar support pointer?
-----------------------------------
YES.
private LinkedList nextNode =null;
consider this line ; This line creates a pointer to a class
LinkedList .
nextNode=new LinkedList(datum);
This statements are use to insert first data to Linkedlist
nextNode.add(datum) is used to insert many data....
Class Inheritance
-------------------
If the Class is using another class variable in that case
you had to use <--- "extends" backward arrows
and front arrows --> for implements..
Implements is used when you use friend function.
CDollar ADvantages over JAVA and other Programming Languages
----------------------------------------------------------------------------------
A) CDollar is the combination of JAVA , C/C++, and Advanced OOPS.
b) CDollar will only accept the shortest attractive syntax.
c) CDollar also used for construction of any datastructures.
d) CDollar helps the developers to provide inheritance by not using extends
keyword
and call the class in main program when use in linux.
e) CDOLLAR Solves diamond Problem with multiple Inheritance when used in linux.
f) It also supports friendly function, pointers , and structures.
g) CDollar support Virtual memmory and garbage collection.
h) It is efficient, fast and easy to understand, and it is a OOPS Technology.
i) CDollar is a High level language.
j) CDollar is highly portable language
k) Using CDollar you can create any datastructures as libraries and
use it in your Application program.
l) CDollar language is a structured and object programming language.
m) CDollar has OOPS concepts like JAVA.
n) CDollar have the concept of Packages,etc.
o) CDollar have the concept of constructor or destructor and had magic oops concepts.
p) It Support functions with Default Arguments
q) It Supports Exception handling
r) It Support Generic Programming
s) It have pointer and Nodes..
t) CDollar is much simpler oops concepts, which leads to faster development and less mental
overhead.
u) CDollar is almost always explicitly compiled
w) CDollar is easy to learn. CDollar was designed to be easy to use and is therefore easy to write,
compile, debug, and learn than other programming languages.
CDollar is object-oriented. This allows you to create modular programs and reusable code.
CDollar is platform-independent.
x) CDollar creates .wl  and  .exe  or  .dll   files   and  it  can be  used  with   CDollar  main  program   (CWE  EDitor  )   to  create  a  complete  software.
y) CDollar will compile and run at same time where other technology can't
do
z) CDollar is mainly used in complex programming , Billing the
goods,Graphics,etc
AA) CDollar is platform independant language
BB) CDollar is an interactive Technology.
FAQS
------
A) A C Programmer or any oops developer can easily
study it....

Note:
CDollarv.2 ,CDollarv.1 ,CDollarv.3 is not a Version. Cdollarv.3 is a improved compiler.
CDollarv.3 ,CDC is a compiler and CDollarv.4 is a Translator and translate to
.wl files and
CDRUN is responsible for running the CDollar Program.


JDOLLAR-CDOLLAR  with  VS-OS  screenshots
=========================================

Program-1
=======

<CDollar>


<IMPORT>

<%


class GUI1  <--- IconImage  --> <HEAR>


{

Shared <RADIO> r <GWT=6>(); //declare  a  radio
Shared <TEXTFIELD> l3 <GWT=3> (); // declare  a text box
Shared <CHECKBOX> l5 <GWT=5> ("YES",false,r); //declare  a  radio button
 Shared  <CHECKBOX> l51 <GWT=5> ("NO",false,r); //declare a   radio  button
 
Shared  <LISTBOX> lb <GWT=7>();// declare  a listbox
 Shared  <COMBOBOX> cb <GWT=8>();//declare  a  combo box

 Shared  <Str>  s= "";
<ITEMSTATECHANGED>  //if  you choose  checkbox  or  combox or  listbox
{

if  (ie.<ITEMSELECTABLE> == l5)

l3.<VALUE>("YES");  //set  text value  =yes


if  (ie.<ITEMSELECTABLE> == l51)

l3.<VALUE>("NO"); //set  text value  =no


if  (ie.<ITEMSELECTABLE> == cb)
l3.<VALUE>(((<COMBOBOX>) ie.<ITEMSELECTABLE>).<SELECTITEM>);

//set  text value  =combobox  select item


if  (ie.<ITEMSELECTABLE> == lb)

l3.<VALUE>(((<LISTBOX>) ie.<ITEMSELECTABLE>).<SELECTITEM>);
//set  text value  =lsit  box  select item

s=l3.<ASSIGN>();  //get  textbox  value  and   assign  to  s

}

   public void  CDOLLAR-Main( ) {
   
  abrpaint g  =<NEW>  abrpaint();//  <NEW>  for  creating object  for  class 

  <IMAGE>
     //GUI1  g  = <NEW> GUI1();
    <LABEL> l1 <GWT=1> ("CDollar  GUI  Programming");  //creating  instance  of   label
<BUTTON> l2 <GWT=2> ("CDollar  GUI  Programming");  //creating  instance  of   button
//<TEXTFIELD> l3 <GWT=3> ();  
<TEXTAREA> l4 <GWT=4> (12,40);//creating  instance  of  textfield  
//<CHECKBOX> l5 <GWT=5> ("Yes"); 

l5.<SOUND>(g);//add listener  to  radio button
//<CHECKBOX> l51 <GWT=5> ("NO");


l51.<SOUND>(g); //add listener  to  radio button 

       l3.<VALUE>("<THIS> is a textbox");  //set  value  of  text field
       l4.<APPEND>("Number of columns in this textarea: " +   l4.<COLS>);  //append text area  and  display no of cols

       
       //used to add components to the Graphics 
       g.add(l1);
      g.add(l2);
      g.add(l3);
       g.add(l4);
   g.add(l5);
    g.add(l51);
     
     
     //add  some  items  to listbox
lb.add("CDOLLAR"); 
lb.add("JAVA");
lb.add("JDOLLAR");
lb.add("C");
lb.add("MAC");
 g.add(lb);lb.<SOUND>(g); //add  listener  to  listbox
 //add items to combobox  
cb.add("CDOLLAR"); 
cb.add("JAVA");
cb.add("JDOLLAR");
cb.add("C");
cb.add("MAC");
 
    g.add(cb);cb.<SOUND>(g); //add listener to  combobox
       
       
       
     g.<SIZE>(500,700); //set  size  of  graphics frame
     g.<FLOWLAYOUT> //set  flowlayout
      g.<VISIBLE=TRUE> //set  frame to be  visible
     
     
  }
  
  
  Shared  class abrpaint  <--- GUI1
{
<PAINT>  //call  paintmethod

{

<DRAWTEXT>("CHOOSEN  CHOICE  is"+s,400,500);  //draw  string  at  coordinates  400,500

<RECT>(20,10,100,60); //drow a  rect

}

}


}


%>


?>



Output  in  VS-oS  (linux  type  os)
========================





Program-2
=======


<CDollar>


<IMPORT>




<%
   class  HOUSE  <--- Graphics

{

 public void  CDOLLAR-Main( )
{

houseparts a  = <NEW> houseparts();

 a.<SIZE>(500,700);
     
     a.<FLOWLAYOUT>
 a.<VISIBLE=TRUE>

}



Shared class houseparts  <--- HOUSE
{
 <PAINT> 
    { 
        background(g); 
        house (g); 
        roof1 (g); 
        roof2 (g); 
        windows (g); 
        framing (g); 
        extras (g); 
        text (g); 
    } 
      
    public void background(<DRAW> g) 
    { 
       // <SET>Background (COLOR=white); 
        
        <SETCOLOUR>(COLOR=black);
         
  
  
        <FILLOVAL> (15,35,170,55); 
        <FILLOVAL> (20,20,160,50); 
        <FILLOVAL> (350,50,170,55); 
        <FILLOVAL> (355,35,160,50);
        
  
        
       
        <SETCOLOUR>(COLOR=cyan);  
        <FILLOVAL> (650,035,120,120); 
        <SETCOLOUR>(COLOR=green);  
       <ARC>(10,20,180,190,160,60);
  <FILLARC>(230,15,150,200,150,75);
    } 
      
    public void house (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=yellow);    
        <FILLRECT> (100,250,400,200); 
        <FILLRECT> (499,320,200,130); 
        <SETCOLOUR>(COLOR=green);      
        <FILLRECT> (160,150,60,90); 
        <FILLRECT> (245,380,110,70); 
        <FILLRECT> (508,350,180,100); 
        <SETCOLOUR>(COLOR=yellow);  
       <FILLOVAL> (282,412,10,10); 
        <FILLOVAL> (307,412,10,10); 
          
    } 
      
    public void roof1 (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=pink);  
        int x[] = {98,300,501}; 
        int y[] = {250,130,250}; 
        <FILLPOLYGON>(x,y,3); 
    } 
      
    public void roof2 (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=orange); 
        int x[] = {499,499,700}; 
        int y[] = {320,249,320}; 
        <FILLPOLYGON>(x,y,3); 
    } 
      
      
    public void windows (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=white);  
       <FILLOVAL>(521,350,68,31); 
        <FILLOVAL> (606,350,68,31); 
        <FILLRECT> (121,261,78,78); 
        <FILLRECT> (121,361,78,78); 
        <FILLRECT> (401,261,78,78); 
        <FILLRECT> (401,361,78,78); 
        <FILLRECT> (241,261,118,78);    
       <SETCOLOUR>(COLOR=white);
        <FILLRECT> (125,265,70,70); 
        <FILLRECT> (125,365,70,70); 
        <FILLRECT>(405,265,70,70); 
        <FILLRECT> (405,365,70,70); 
        <FILLRECT> (245,265,110,70); 
        <FILLOVAL> (525,353,60,25); 
        <FILLOVAL> (610,353,60,25); 
    } 
      
    public void framing (<DRAW> g) 
    { 
         <SETCOLOUR>(COLOR=black);  
          
        <FILLRECT> (298,380,2,70); 
        <FILLRECT> (508,382,180,2); 
        <FILLRECT> (508,417,180,2); 
        <SETCOLOUR>(COLOR=white);  
        <FILLRECT> (157,265,5,70); 
        <FILLRECT> (157,365,5,70); 
        <FILLRECT> (437,265,5,70); 
        <FILLRECT> (438,365,5,70); 
        <FILLRECT> (297,265,5,70); 
        <FILLRECT> (125,298,70,5); 
        <FILLRECT> (125,398,70,5); 
        <FILLRECT> (405,298,70,5); 
        <FILLRECT> (405,398,70,5); 
        <FILLRECT> (245,298,110,5); 
        <FILLRECT> (245,375,110,5);  
        <FILLRECT> (240,375,5,75); 
        <FILLRECT> (352,375,5,75); 
        <FILLRECT> (508,345,180,5); 
        <FILLRECT> (503,345,5,105); 
        <FILLRECT> (688,345,5,105); 
    } 
      
    public void extras (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=orange);  
        <FILLOVAL> (160,105,35,45); 
        <FILLOVAL> (170,95,35,45); 
        <FILLOVAL> (160,85,35,45); 
        <FILLOVAL> (170,35,35,45); 
        <FILLOVAL> (160,25,35,45); 
        <FILLOVAL> (170,15,35,45); 
        <SETCOLOUR>(COLOR=orange);  
        <FILLRECT> (508,450,180,150); 
        <FILLRECT> (245,450,107,50); 
        <FILLRECT> (274,500,50,40); 
        <FILLRECT> (274,520,250,45); 
        } 
          
    public void text (<DRAW> g) 
    {    
        <SETCOLOUR>(COLOR=orange);              
                <DRAWTEXT>("House portrait by: wilmix jemin",390,70); 
    } 

    }
    
    
    

}

%>
?>

Output
=====



Explanation
=======
Now  listen...when   CDollarc   is   compiled    with    HOUSE.cdollar  it  produces   intermediate  encode  code that can't  be understood  by any body  and  it  calls   CDollarv.4   which  calls   CDC  which   compiles  the   code and  finally  it  produces   .wl  file.  So .wl file   is the  final class   file  of JDollar-cdollar.


=======================================================

        UNIT-3:  JDollar(JWEB)  with  GDollar    and Advantages  over other  P.L

======================================================


JDollar-GDollar


======================================================

 Introduction   to   GDollar Technology  
======================================================

GDollar Technology is a modern Programming Language consists of JAVA OOPS, Behave
like C/C++ ,GDollar Advanced  OOPS Networking, RUN and compile at same time,it  is  used in Software Development , cloud computing ,Research, and ,Advanced OOPs.
It is used in case of  constructing  datastructures,etc.

SYNTAX FOR GDollar (.Gdollar) (beautiful syntax)
---------------------------------------------------------------
<GDollar>

<%
<! GDollar OOPS Logic !>

public void GDollar-Main()
{

}
?>

public void GDollar-Main()
note: This should be saved in filename.Gdollar
----

How GDollar Technology Works  for  GDollar-LIB?

At  first  .Gdollar  is compiled by GDOLLARc compiler
GDollarc   convert  to  intermediate  code  called as   filename.C$.  and  it  calls 
GDollarv.4  compiler.
After that GDOLLARv.4  compiles the  intermediate  code
    to create   .dll  file  immediately
so  that    user  can  directly  use  in   GDollar-CWE Editor  program.

How   GDollar  Technology  works   for  GDollar-MAIN(CWE)?

When  Gdollar  compiler   compilers   a    Gdollar  program  it
generates  .dll and  .exe  file  for  futhure  use.

Why  you  use   Gdollar  technology? what   is the  major  advantage  of  Gdollar?
Since    after  compiling  Gdollar   code  it  generates  
intermediate  encode  (.C$)  files.  That   hacker  or  any  body  
cannot  understood  the  code.  ie)  Hacker  cannot   take
the  orginal  source  code.
GDollar  technology  prevents   code  stealing  using this  concept.


Why GDollar?
-------------

GDollar  is   a  Programming  Langauge   and  it  used    for  constructing   advanced   datastructures, complex  datastructures,  and  focused  on compiler  design   and  it   is  mostly  by  universities,colleges,companies,industries.
it  is   invented    by   wilmix jemin  in  JAVA ,C/C++ and  editor using  JDollar(JWEB)   P.L  at  2016.

What   are  Gdollar  Modules? 

Gdollar   has   5  modules   they  are....
a) GDollar -LIB 
b)  GDollar -Advanced OOPS (CWE -Editor)
c)  GDollarv.4 (intermediate  encoder)
d) JSLASH  (autogenerated  technology  with  in  few  seconds) (GDOLLAR COMPILERDESIGN)
e) GDollar - CJAVA



SYNTAX-1 (used only for  creating  libraries - .Gdollar)
------------------------------------------------------------


<GDollar>
<IMPORT> Packagename;
<CLIB>

<%

<! OOPS Logic and  datastructures !>

%>

How GDollar is formed ? What are its Advantages Over Native language JAVA Programming?
------------------------------------------------------------------------

GDollar is formed in C++ OOPS concepts..
JAVA borrowed C++ OOPS concepts but
GDollar borrowed C++ OOPS concepts and JAVA oops and it has
Attractive syntax ; Plus in-build functions
for Program and it is responsible for creating
libraries (.dll). JAVA has attained the Programming
standards, But GDollar attains combination of C Technology
and JAVA Technology advantages.
GDollar Generates .dll files
but JAVA Generated .class files.
GDollar Has Advanced OOPS than JAVA 1.8.


 GDollar    DATATYPES,LOOPING,Statement,Operators

 GDollarc    Keywords
===================

 <GDollar>    <CUTIL> <IMPORT>
abstract     add     as     ascending
 async     await     base     bool
 break     by     byte     case
 catch     char     checked     <CLASS>
 const     continue     decimal     default
 delegate     descending     do     double
 dynamic     else     enum     <EQUALS>
 explicit     extern     false     finally
 fixed     float     for     foreach
 from     get     global    goto
group     if     implicit     in
 int     interface     internal     into
 is     join     let     lock
 long     <PACK>     <NEW>     null 
 object     on     operator     orderby
 out     override     params     partial
 private     protected     public     readonly
 ref     remove     return     sbyte
 sealed     select     set     short
 sizeof     stackalloc     Shared     string
 struct     switch     this     throw
 true     <TRY>     typeof     uint
 ulong     unchecked     unsafe     ushort
 using     value     var     virtual
 void     volatile     where     while
 yield  <%   %>


OTHER KEYWORDS IN GDOLLAR
--------------------------------------------------
AND -> AND operator
NOT -> NOT operator
# -> NOTEQUALS
RUN -> Runnable used in thread
TH-> Thread
<EXE> -> Exception
Friends -> Friend function

OTHER ATTRACTIVE SYMBOLS in GDOLLAR
-------------------------------------------
--> => implements
<-- => extends

PRIMITIVE  DATATYPES  in  GDOLLARC

The following table lists the available value types in CDollarcc (v.1)

bool    Boolean value    True or False    False
byte    8-bit unsigned integer    0 to 255    0
char    16-bit Unicode character    U +0000 to U +ffff    '\0'
decimal    128-bit precise decimal values with 28-29 significant digits    (-7.9 x 1028 to 7.9 x 1028) / 100 to 28    0.0M
double    64-bit double-precision floating point type    (+/-)5.0 x 10-324 to (+/-)1.7 x 10308    0.0D
float    32-bit single-precision floating point type    -3.4 x 1038 to + 3.4 x 1038    0.0F
int    32-bit signed integer type    -2,147,483,648 to 2,147,483,647    0
long    64-bit signed integer type    -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807    0L
sbyte    8-bit signed integer type    -128 to 127    0
short    16-bit signed integer type    -32,768 to 32,767    0
uint    32-bit unsigned integer type    0 to 4,294,967,295    0
ulong    64-bit unsigned integer type    0 to 18,446,744,073,709,551,615    0
ushort    16-bit unsigned integer type    0 to 65,535    0

OPERATORS  in  GDollarc

Operator Type    Category    Precedence
Unary    postfix    expr++ expr--
prefix    ++expr --expr +expr -expr ~ !
Arithmetic    multiplicative    * / %
additive    + -
Shift    shift    << >> >>>
Relational    comparison    < > <= >= instanceof
equality    ==  NOT=
Bitwise    bitwise AND    &
bitwise exclusive OR    ^
bitwise inclusive OR    |
Logical    logical AND    AND
logical OR    OR
Ternary    ternary    ? :
Assignment    assignment    = += -= *= /= %= &= ^= |= <<= >>= >>>=

GDollarc  has the  following type of operators:

Arithmetic Operators
Relational Operators
Logical Operators
Bitwise Operators
Assignment Operators
Misc Operators


Arithmetic Operators
Example:
Assume variable A holds 1 and variable B holds 7 then:


Operator    Description    Example
+    Adds two operands    A + B = 8
-    Subtracts second operand from the first    A - B = -6
*    Multiplies both operands    A * B = 7
/    Divides numerator by de-numerator    B / A = 7
%    Modulus Operator and remainder of after an integer division    B % A = 0
++    Increment operator increases integer value by one    A++ = 2
--    Decrement operator decreases integer value by one    A-- = 0

Relational Operators
Assume variable A holds 30 and variable B holds 10, then:

Show Examples

Operator    Description    Example
==    Checks if the values of two operands are equal or not, if yes then condition becomes true.    (A == B) is not true.
!=    Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.    (A != B) is true.
>    Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.    (A > B) is  true.
<    Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.    (A < B) is not true.
>=    Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.    (A >= B) is  true.
<=    Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.    (A <= B) is not true.
Logical Operators
Assume variable A holds Boolean value true and variable B holds Boolean value false, then:

Operator    Description    Example
&&    Called Logical AND operator. If both the operands are non zero then condition becomes true.    (A && B) is false.
||    Called Logical OR Operator. If any of the two operands is non zero then condition becomes true.    (A || B) is true.
!    Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.    !(A && B) is true.

Bitwise Operators
Bitwise operator works on bits and perform bit by bit operation. The truth tables for &, |, and ^ are as follows:

p    q    p & q    p | q    p ^ q
0    0    0    0    0
0    1    0    1    1
1    1    1    1    0
1    0    0    1    1


Operator    Description    Example
&    Binary AND Operator copies a bit to the result if it exists in both operands.
|    Binary OR Operator copies a bit if it exists in either operand.
^    Binary XOR Operator copies the bit if it is set in one operand but not both.    
~    Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.    
<<    Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.    
>>    Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.    

Assignment Operators
There are following assignment operators supported by CDollarcc:
Operator    Description    Example
=    Simple assignment operator, Assigns values from right side operands to left side operand    C1 = A1 + B1 assigns value of A1 + B1 into C1
+=    Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand    C 1+= A1 is equivalent to C 1= C1 + A1
-=    Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand    C1 -= A1 is equivalent to C 1= C1 - A1
*=    Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand    C1 *= A1 is equivalent to C1 = C1 * A1
/=    Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand    C 1/= A1  is equivalent to C1 = C1 / A1
%=    Modulus AND assignment operator, It takes modulus using two operands and assign the result to left operand    C1 %= A1 is equivalent to C1 = C1 % A1
<<=    Left shift AND assignment operator    C1 <<= 2 is same as C1 = C1 << 2
>>=    Right shift AND assignment operator    C 1>>= 2 is same as C 1= C1 >> 2
&=    Bitwise AND assignment operator    C1 &= 2 is same as C 1= C1 & 2
^=    bitwise exclusive OR and assignment operator    C1 ^= 2 is same as C1 = C1 ^ 2
|=    bitwise inclusive OR and assignment operator    C1 |= 2 is same as C1 = C1 | 2

Miscellaneous Operators
There are few other important operators including sizeof, typeof and ? : supported by Cdollarcc.

Operator    Description    Example
sizeof()    Returns the size of a data type.    sizeof(int), returns 4.
typeof()    Returns the type of a class.    typeof(StreamReader);
&    Returns the address of an variable.    ANDa;  returns actual address of the variable.
*    Pointer to a variable.    *a  creates pointer named 'a' to a variable.
? :    Conditional Expression    If Condition is true ? Then value A : Otherwise value B
is    Determines whether an object is of a certain type.    If( Girafee is animal) // checks if Girafee is an object of the Animal class.
as    Cast without raising an exception if the cast fails.    Object obj = new StringReader("Wilmix");
StringReader r = obj as StringReader

Operator Precedence in GDollarc
Operator precedence of  the  expression.some operators have higher precedence than others; for example, the multiplication  or  division  operator has higher precedence than the addition operator.
For example x = 6 + 12 * 2; here, x is assigned 30, not 36 because operator * has higher precedence than +, so the first evaluation takes place for 12*2 and then 6 is added into it.
Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators are evaluated first.

Category    Operator    Associativity
Postfix    () [] -> . ++ - -    Left to right
Unary    + - ! ~ ++ - - (type)* & sizeof    Right to left
Multiplicative    * / %    Left to right
Additive    + -    Left to right
Shift    << >>    Left to right
Relational    < <= > >=    Left to right
Equality    ==  NOT=    Left to right
Bitwise AND    &    Left to right
Bitwise XOR    ^    Left to right
Bitwise OR    |    Left to right
Logical AND    AND    Left to right
Logical OR    OR    Left to right
Conditional    ?:    Right to left
Assignment    = += -= *= /= %=>>= <<= &= ^= |=    Right to left
Comma    ,    Left to right

Gdollar   Statements    consists  of   Print  statements,
Read  Statements , LOOPING  Statements 

Read  Statements
Console.ReadKey();==>  Read   a  vaue  from  console
Print  Statements

SYNTAX:
GDOLLAR.WriteLine(String+datatype);

Types of Looping Statement
=============================

For Loop
========

For  Loop  operates   when  the  condition  met  >=  or  <= or  <  or  >.
At  first  counter  is  intialized   to  a  value  and   it  is   followed   by  a  condition
and   it  is   followed   by  increment  or   decrement  operator
A  block inside   the   for  loop  to  be  executed   if  the  condition  met until   false.


SYNTAX:
=======

for  (index=intialialize value; index <> condition ;  incrementor  or  decrementor)

{


<!  BLOCK  STATEMENTS  !>



}


While Loop
==========

While  Loop   operates   when  the  condition  met  >=  or  <= or  <  or  > or  == .which  is   tested   at  the  TOP  of  the  loop.
A  block inside   the   WHILE  loop  to  be  executed   if  the  condition  met until   false.


SYNTAX:
=======

while  (index  <>  condition)

{
<!  BLOCK  STATEMENTS  !>

}



Do  – While Loop
================

Do - While  Loop   operates   when  the  condition  met  >=  or  <= or  <  or  > or  == ; which  is   tested   at  the  bottom  of  the  loop.
A  block inside   the  Do-WHILE  loop  to  be  executed   if  the  condition  met until   false.

SYNTAX:
=======

do

{
<!  BLOCK  STATEMENTS  !>

}

while (index  <>  condition)

foreach
========

The for-each loop introduced in CDollarc. It is mainly used to traverse array or collection elements. 
The advantage of for-each loop is that it eliminates the possibility of bugs and makes the code more readable.



Advantage of for-each loop:
===========================

It makes the clear  consise of  the  code.

It eliminates the possibility of programming errors.

for  (index  in  collections)

{
<!  BLOCK  STATEMENTS  !>

}


Types of Conditional Statement
=================================

 If Statement
==============

If   Statement   operates  when  the  condition  met  it  will
execute   the  block  inside  the  if  statement.

SYNTAX:
=======

if  (condition1 .....  Condition.n)

{

<! BLOCK  STATEMENTS>

}


If – Else statement
====================
If -Else  Statement   operates  when  the  condition  met  it  will
execute   the  block  inside  the  if  statement
or  else   execute    the  block  inside   else  statement.

SYNTAX:
=======
if  (condition1 .....  Condition.n)
{
<! BLOCK  STATEMENTS>
}
else
{
<! BLOCK  STATEMENTS>
}


If- Else-if statement
========================
If -Else  Statement   operates  when  the  condition  met  it  will
execute   the  block  inside  the  if  statement
or  else   execute    the  block  inside   if -else  statement  followed  by  a  condition.


SYNTAX:
=======

if  (condition1 .....  Condition.n)

{

<! BLOCK  STATEMENTS>
}
else  if  (condition1 .....  Condition.n)

{
<! BLOCK  STATEMENTS>

}

Switch Statement
================

Switch  statement   will   test   for  the  eqaulity  when  there   is  match   with  the value  of  expression.
The   Statement  inside  the    default   statement   is  executed   last   when  if none of the above case is satisfied.
if  the   statement  is not  followed   by  break  then   
another   switch  statement  with   equality  is   executed  next.
or   else   it  will    skip  that  statement.



SYNTAX:
=======

switch (variable) {

  case v1:
        statements 
        break;
  case v2: 
        statements 
        break;
  case v3:
  case v4:        
        statements 
  . . .
  default:
        statements
        break;
}


Types of Flow Control Statement
================================

Return Statement
================
Return  Statement  is  used  to  return  a  value  
when  a  Function  is   a   return  type.
syntax:  return value;

Continue Statement
===================
Continue   statement  is  used  to  continue  the  loop.

SYNTAX:
=======
continue;

Break Statement
=================
Break   statement  is  used  to  Skip   from  the  loop.

SYNTAX:
=======
break;

Goto Statement
===============

Goto  Statement  is   used  as   a  climber  to  goto   another  block  and  execute
it.

SYNTAX:
=======
goto label;

Throw Statement
===============
Usually the throw statement is used with try-catch or try-finally statements. 
A throw statement can be used in a catch block to re-throw the exception that the catch block caught.

SYNTAX:
=======
throw  exception;
ARRAYS
ARRAY  is  to   store   a    value  in  a   location
which   uses   stack  datastructures..


===================================================
                        
                 GDollar ADVANCED CONCEPTS

=====================================================


ADVANCED OOPS CONCEPTS
--------------------------------------------
Example -3:
------------
Write a Program to print two String and add String 100 to
ArrayList.
and Technologies for year
2016  is C, GDollar ,GDollar,CHDOLLAR, JDOLLAR,JSTAR, JSAUCER.

Program :abc.Gdollar
-------------------

<GDollar>
<IMPORT>  P
<%

class abc
{
public void GDollar-Main() 
{
int i;
GDOLLAR.WriteLine("\nList of Technologies in year "+"2016 ");

string i1="weew";
GDOLLAR.WriteLine("wilmix"+i1);
GDOLLAR.WriteLine(" \njemin"+"is going");

}
}
%>

What will be the Output when you run using ?
>GDOLLARc abc.GDollar
Note:  it  will create .dll  file   for  that.

Example-4:
-----------
Write a Program to add 1 lakh Natural integers using arraylist
using   GDollar  LIB.
Program2:
---------
<GDollar>
<CUTIL> //to  load   GDollar  packages
<IMPORT>  P
<%
public class Program2 
{
public  Shared void  LIB( )

{
<AList> ar= <NEW> <AList> ();
for (int i=0;i<=100000;i++)
ar.add(i,i);
}
}
%>

what  is   the   intermediate   code   when   Gdollar  is  compiled
by  GDollarc..
Program2.C$

<CDollar>
<CUTIL>
<IMPORT>  P
<%
public class Program2 
{
public  *AB007 void  LIB( )

{
*AB043 ar= *AB091 *AB043 ();
for (int i=0;i<=100000;i++)
ar.add(i,i);


}
}
%>

What   is  the  use?
Since   we   can   reuse   the  code  ,  and  which means   that   it  is   the  proof
that  this  developer  had   coded   it.
when   GDollarc  is   used   GDollarc  compiler   produces  intermediate   code
and   which  again  calls  CDollarv.4  and which    creates  .dll file.



======================================================                                
     GDollar  ADVANCED  DATA STRUCTURES   THEORY  used  in CWE EDITOR


GDollarArrays

SYNTAX for GDOLLARArrays:
--------------------------------------
CARRAYS list1 = new CARRAYS(string);
to add any collection objects to array use
add (String) functions and to Display those
objects use list1.Display();
Any class that use CARRAYS you should extends Array in class...


TREEOFARRAY
---------------------
Write a Program to add 1 lakh Natural integers incremented by 10 using arraylist
and add the arraylist objects to TreeOfARRAY
what happens when you compile and execute the given the below program?

SYNTAX for TreeofArray:
--------------------------------------
TreeArray <name> = new TreeArray(String);
<name>.add(elements);
where elements may be string or collections....
 It store other collection objects and stores huge amount of data
in tree format.

LISTOFARRAY
---------------------
SYNTAX for List of Array:
--------------------------------------
LArray <name> = new LArray(string);
<name>.add(elements);
The elements may be string or collection elements.

Ans: It store other collection objects and stores huge amount of data
in tree format and sorts the elements in descending order and allow to insert the
element in to middle of list. This means act like combination of Set and Linked List , and Tree....



=========================================================

MISC ,Fundametals of GDollar, Keywords,Operators,loops,Datatypes,Inner class, OOPS
concepts of GDollar ,and collections

=========================================================

GDollar OUTPUT STATEMENT
----------------------------------------------

GDollar.WriteLine(" "+" ");
It is used for printing the output followed by line.
We had to add + operator to concatenate the outputs.....

String
------------
String is represented by <Str> notation.
a) char[]  obj = <NEW> char[2];
        obj[0] = 'x';
        obj[1] = 'x';
        string eS = <NEW> string(obj);
This statement is used to create an object...
b) <Str> <strname> = value;
But this Statement will not create an object...
but it stores the value...
the differences between
a) if ( s1==s2)
== means it is used to compare the values...
b) if s1.<EQUALS>(s2)
EQ means EQUALS is used to compare objects..
EXAMPLE
<GDollar>
<CUTIL>
<IMPORT>  P
<%
public class Program2 
{
public  Shared void  LIB( )

{
<AList> ar= <NEW> <AList> ();
for (int i=0;i<=100000;i++)
ar.add(i,i);



 if (ar.<EQUALS>(ar)) // compare   two objects

GDOLLAR.WriteLine(""+ar);


}
}
%>

GDollar COLLECTIONS
------------------------------------
Why we use collections in our software development?
Because for various projects we will use various kinds of
datastructures that's why collections are focused.

Q: What are the Important concepts of Software Development?

ARRAYLIST
----------------
SYNTAX:
------------
<AList>  arraylistobjectname = <NEW> <AList>();
But type may be Object, int, Double,String,etc.
Why we focus Arraylist ?
Since ArrayList involves Powerful insertion and search mechanism when
compared to array.
So we focus it.
Some built in functions available in ArrayList they are add and remove.
syntax : arraylistobjectname.add(loc,<datatype>);
loc means   location of  the  arraylist.  
syntax: arraylistobjectname.remove(<datatype>);
How did you iterate the ArrayList?
by  using While  statement ...

LinkedList
----------
<LList>  arraylistobjectname <NEW> <LList>();
But type may be Object, int, Double,String,etc.
As according to collection concepts , built in functions are Designed for
LinkedList they are add and remove.

Actually when you study about Datastructures of LinkedList
and here we Designed the LinkedList using the LinkedList code
as mentioned in above that is LinkedList.c$. And add more functions...
and we use GDollar Generics...
What is the function of LinkedList? Why we use LinkedList?
In ArrayList You can't insert element in to the middle
or first or last so LinkedList is focused....
LinkedList is a Good example of Train....

VECTOR STACK
-----------------------
Here   Vector  implements  Stack.
So we can mention in short notation as VList.
 and  Vector  has  push  ,pop, and  peek() apis.
push  for  push an  element   ,pop  for  POPing  the  last  element.
peek for  showing   the  firstelement in vector  stack
Example:
=======
<GDollar>

<CUTIL>
<IMPORT>  P
{
public  class   abc

{

public  void  lib()
{
 VS s = <NEW> VS(3);
        s.<PUSH>(1);
        s.<PUSH>(2);
        s.<PUSH>(3);
        s.<PUSH>(4);
   
 while (NOTs.empty())
      {
            GDOLLAR.WriteLine("Top element is " + s.peek());
             GDOLLAR.WriteLine("Removed the element " + s.<POP>);
      }

}

     
}


}



OOPS in GDollar
------------------------------
A) INHERITANCE NOT USING EXTENDS METHOD...

C.GDollar

-------------

<GDollar>

<CUTIL>
<IMPORT>  P
{

class A
{
public A() { GDOLLAR.WriteLine("A's called"+"n"); }
}
class B
{
public B() { GDOLLAR.WriteLine("B's called"+"n"); }
}
class C
{
public C() { { GDOLLAR.WriteLine("C's called"+"n"); } }
public  void  lib()
{
<NEW> A();
<NEW> B();
<NEW> C();
}

}

}
Output:
------

B) POLYMORPHISM in GDollar
-----------------------------------------------
What is polymorphism?

It is Means action on method to do different things
based on the object that is action upon.

Example:
-------------
Write a Program to compute Rectangle Area and Triangle area
using Polymorphism.

Geometry.Gdollar
----------------------------

<GDollar>


<IMPORT>  P
{

public  class  EVEN
{

public void ISEVEN(int num1)
      {
         
        
         

for (int i=2;i<num1;i++)
{
if  (num1% 2==0) 

 GDOLLAR.WriteLine("EVENNOS="+num1);



}
       
      }


      public void LIB()
      {
        
         int no = 100;
        
         int r;
         EVEN n = <NEW> EVEN();


         n.ISEVEN(no);
     

       
      }


}

}





C) Write a Progam to List Faculty , students using Diamond method in GDollar
:-
Note: Without Extends methods its calls methods and value when new ()
is intialized.
This is the Major Advantage of GDollar over native programming languages
like JAVA.

Program: TA.Gdollar
--------------

<GDollar>


<IMPORT>  P
{

class Person {
  
   
   Person(){}
public Person(int x)  { GDOLLAR.WriteLine("Person::Person(int ) called"+x);   }
}
 
class Faculty  {

public Faculty(int x)

{

<NEW> Person(x);
       GDOLLAR.WriteLine("Faculty::Faculty(int ) called"+x);
    }
}
 
 
class Student  {
  
public  Student(int x) {
<NEW> Person(x);
        GDOLLAR.WriteLine("Student::Student(int ) called"+ x);
    }
}


 
class TA   {
    TA(int x)  {
    <NEW> Faculty(x);
    <NEW>  Student(x);
   
        
   GDOLLAR.WriteLine("TA::TA(int ) called"+x);



    }
     
 
 public void LIB( )
{
    <NEW>  TA(30);


}

}



}


What will be the output ?
Tue Aug 18 07:59:57 GMT+00:00 2015*GDollar: Person::Person(int ) called 30Faculty::Faculty(int ) called
30Person::Person(int ) called 30Student::Student(int ) called 30TA::TA(int ) called 30

How to run this program?
GDOLLARc <Filename.Gdollar>

C) ABSTRACT CLASS

What did you meant by Abstract class?

Abstract class defines an Abstract concept which can't
be instanated using new Operator().
Where compare to multiple Inheritance it has an implementation
where multiple Inheritance cannot have.

<GDollar>

<IMPORT>  P
{


    class Programs1
    {
        public void LIB()
        {
           Subject subject = <NEW> Subject();
           GDOLLAR.WriteLine(subject.Describe());
            
        }
    }

    abstract class Topic
    {
        public virtual string Describe()
        {
            return "we  are  seeing  science  subject";
        }
    }

    class Subject : Topic
    {


public  string Describe()
        {
            return "We are seeing  maths  Geometry  subject";
        }
    }




}


=========================================================
More about COLLECTIONS
---------------------------------------------
Treeset
------------
Treeset represent a collection that uses Tree datastructure for storage
Items in the collections are stored in Ascending or descending order.
<TS> objectname = new <TS>(<String>);
objectname.add(elements);
Write a GDollar Program about Treeset?
remaining things Developer should fill it.


<GDollar>

<CUTIL>
<IMPORT>  P
{

class  tree

{

public  void  lib()

{

    <TS> t = <NEW>  <TS>("wee");
t.add("13");
t.add("15");
t.add("12");
t.add("1");
GDOLLAR.WriteLine(""+t.ASCDisplay());
GDOLLAR.WriteLine(""+t.DESCDisplay());

}         

}


}





Output:
------
Order=ASC[4][31][100][211][1123]
*******************************
Order=DESC[1123][211][100][31][4]
*******************************
Order=ASC[abraham][dion][priya][rahul][shiyam][wilmix]
*******************************
Order=DESC[wilmix][shiyam][rahul][priya][dion][abraham]

Operators conditions and loops
--------------------------------------------------
Operators
---------
+ => ADD
++=> Increment
- => Substract
--=> Substract
* => Mulitply
/ = Division
~ => bitwise unary not operator
NOT (!) => flips true values to false and false values to true.
>>, >>>, and << => IT is used to shift all the bits of a number left
or right
a Specified number of places...
Other Operators
----------------
AND => And operator
OR => OR operator
?: => value =condition ? value1 : value2 (similar to if then else)
== => compare two values...
= => Assignment operators
EQ => Compare two objects
Relational Operators
--------------------
> >= => Greater than , Greater than equals.
< <= => Less than , Less than equal
NOTEQ => Equals and not equals
NotEQ simillar to !=
CONDITIONS
----------
IF Syntax:
------------
if <condition> statements;
IF then else Syntax:
----------------------
if <condition> statements else statements1
if <condition> statements1 else if condition1 statement2 .... and soon.
SWITCH Statements:
-------------------
switch (expression)
{
case value1 :
statement1;
[break]
................
case valuen:
statementn;
[break]
-----
default:
default_statement;
}
Explanation:
------------
If the expression is equals value1
statement1 will be executed.
if you use break it comes out of the loop
otherwise it continue to execute next statement.
The default value at the end is optional. It can be included if there are other values that can be held in
your variable but that you haven't checked for elsewhere in the switch statement.
THE WHILE LOOP
-----------------------------
while (<condition> )
{
< Statements block>
}
Note: if the condition is true the block get executed.
otherwise the loop will be continued.
THE DO --- WHILE LOOP
-----------------------------
do
{
< Statements block>
}
while( <conditon> )
Note: if the condition is true the block get executed.
and it is tested at the end of the loop, but not at the
beginning. The loop will be continued until it satisfies the condition.
biggest reason to be use the do - while loop is that
when you need the body of the loop to be run atleast once.
FOR LOOP
--------
for ( identifier=value; cond1; iterator operators)
{
< Block statements >
}
For -EACH Statement
----------------------
            //retrieving value using foreach loop
            foreach (string <VAR> in <OBJECT>)
            {
                statements;
            }
If you add integers (1 to 3) to arraylist
and if you wish to copy and store it in an integer variable
so that you can print the values that is copied from
arraylist.
Then follow this method of for each statements...


string[] hobies = { "twitter","cricket","footbal"};
  foreach (string hob in hobies)
{
GDOLLAR.WriteLine("value="+hob);
}

Output:
-----------
value=twitter
value =cricket
value =footbal
CONTINUE and Break
---------------------------------
Break means it break out of loop
and continue means
it will continue to execute the statements;
for eg)

Program :WHILE LOOP with continue and break if statement...
------------------------------------------------------------------------

<GDollar>

<CUTIL>
<IMPORT>  P
{


public class WHILE
{
public void LIB() 
{
int a=0;
while (a <=10)
{
a++;
GDOLLAR.WriteLine("value="+a);
if ( a==9) continue;
else break;


}


}


}




}







Output:
-------
Wed Aug 19 10:09:23 GMT+00:00 2015*
GDollar: value=1


DATATYPES and OVERLOADING and OVERRIDING CONCEPTS, INNER CLASS
------------------------------------------------------------------------

DATATYPES of GDollar are
-------------------------------
int -> accept only int value
float -> accept float value=>eg) 1.5f
bool => true or false
char => accept character value
byte -> 1 byte
short -> 2 bytes
long-> 8 bytes
double-> for eg) 1.2121233232E9 => Accept double value
ARRAY => It is used to store values and had fixed size.

ARRAY
-------
SYNTAX:

datatype[] object =  <NEW> datatype[10];

<GDollar>


<IMPORT>  P
{

public  class  abc
{
public  void  LIB()
{



int []a =  <NEW> int[10];


for (int i=1;i<=9;i++)
{
a[i]=i;



GDOLLAR.WriteLine(a[i]);
}

}
}


}
OTHER KEYWORDS IN GDollar
--------------------------------------------------
AND -> AND operator
NOT -> NOT operator
# -> NOTEQUALS
RUN -> Runnable used in thread
TH-> Thread
<EXE> -> Exception
Friends -> Frend function
INNER and OUTER CLASS
-----------------------------------------
Inner class are nested inside outer class even if the fields
declared as private members.

<GDollar>


<IMPORT>  P
{

class Outer {
private Shared int privInt = 10;

public void createInnerClass() {
Inner inClass = <NEW> Inner(); 

inClass.access();
}
class Inner { 

public void access()

 {

GDOLLAR.WriteLine("The outer classs privInt is " + privInt);
}
}
}


}



OVERLOADING AND OVERRIDING functions
-------------------------------------------
OVERLOADING
------------
A functions with same name but different signature is called
as Overloading concept.
public void display(int i , String j) {}
=> If you pass int and string values from main program it will call
this function.
ABC a = <NEW> ABC(10,"ewew");
public void display(int i, int j) {}
ABC a = <NEW> ABC(10,20);
=> If you pass int and int values it will call this function.
OVERRIDING
-----------
A function with same name and same signature
will cause overriding....
Overriding can be avoided by using super() keyword.
in another class.

<GDollar>


<IMPORT>  P
{

public class section
  {  
    public virtual string display()  
    {  
        return "CLASSA";  
    }  
  }  
public class student:section
{  
     
    public override string display()  
    {  
        return "CLASSA-100students-computerscience";  
    }  
}  



}

Note: this will cause overriding
and it can be avoided by using super () keyword.

OTHER ATTRACTIVE SYMBOLS in GDollar
-------------------------------------------
--> => implements
<-- => extends


=========================================================

FILE,Other collection concepts,Advanced Concepts of GDollar,MISC-2,Exception and

Error,Garbage collection,Threads,Generics,GDollar Structures.

=====================================================


Advanced Topics in GDollar
-----------------------------

OTHER COLLECTIONS CONCEPTS
---------------------------------------------------
<M> => map MEANS IT CONTAINS KEYS AND VALUE PAIRS...
HashSet
-------------
SYNTAX:
  <HASHSET> h <NEW> <HASHSET>(index);

h.add(data);
<PRINTLN>(""+h.GET());

HASHMAP
----------------
SYNTAX:
 <HASHMAP> h <NEW> <HASHMAP>(index);
 h.put(null, null); //you  can  also  put  null  key  and  null value
 h.put((data), null);

      h.display();
HASHTABLE
----------------
SYNTAX:
HashTable h  <NEW> HashTable(index);
      h.put(key,value);      h.display();
note: hash determines a order in which elements are
stored in the hash; SO it will display according
to hash stored order.
ADVANCED CONCEPTS of GDollar
----------------------------------------------------------
ITERATOR
----------------
Iterator iterate about collection
in the forward direction .
and it will iterate record wise from the List or collection.
foreach( int a in  stringarray)
{
}
Here  foreach  statement  is  used  for  iterative  purpose.


Exception and ERROR
-----------------------------------
Exception is a abnormal condition that arise during
the code sequence at run time.
<TRY> -> try in C/JAVA
<CATCH> -> catch in c/java
<Finally> -> final in c/java
SYNTAX:
-------------
<TRY>
{
< Executable good statements>
}
<CATCH> (<EXE> e)
{
GDollar.WriteLine(""+e);
}
<Finally>
{
<Final block statements>
}
Explanation:
-------------------
When ever the Exception is true statements inside a try
block is executed; otherwise
statements inside a catch block is executed.
Exception occurs or not
final block get executed..
FINAL in GDollar
--------------------------
UnShared keyword means final in GDollar
eg)
UnShared int i=9;
// if a variable is declared as final
that value can't be changed.
eg)
UnShared class abc
{
.......
}
if the class is declared as UnShared it can't
be overridden.
so if the method is declared as UnShared
such method can't be overriden by another class method.


Destructor:
----------
Destructor means object is going to be destroyed.
~
where ~ is the Destructor operator.

Operator Overloading in GDollar
------------------------------------------------
This means we can overload the operators
like + - = / > < >= <=


<GDollar>


<IMPORT>  P
{

UnShared class operatoroverloading
{
    
public Shared void operator *(int s1 ,int s2)
{
int s3=s1 * s2;
GDOLLAR.WriteLine(""+s3);
}
public  Shared void  LIB( )
{
operator *(10,10);

operator *(200,10000);
}



}

}
GENERICS
---------------
GENERICS means which is used to Pass Type as argument as class
for example if you want to pass String , int, float datatypes at the
same time and if you use display method to display the value of any
datatype
so Generic is most useful in that case.


<GDollar>


<IMPORT>  P
{
public class GEN<T>
{
T t;
T display(T t1)
{
t=t1;
return(t);
}
public  Shared void  LIB( )
{
GEN <int> i = <NEW> GEN<int> ();
GDOLLAR.WriteLine(""+ i.display(10));
}
}




}


=========================================================

GDollar STRUCTURES
-----------------------------------
GDollar structure is another user defined data type available in GDollar programming, which allows
you to combine data items of different kinds.
using the same memmory location. It also provide an efficient way of using the same
memory location for multi-purpose.
Thus GDollar Structures is Equivalent = C progamming Structures and union.
and it uses less memmory capacity than any Programming languages. IT is also
used to store collections, objecte ,etc.
IT is the most important datastructure implemented by wilmix jemin j.
He reduces the demerits of C Programming and
C child is GDollar. So GDollar has very beautiful and Advanced Concepts
than
any Programming Languages. And the Native Technology like JAVA
fails to do.
ADVANTAGES:
--------------------
Billing programs, GUI, Record wise Search and Printing ,etc...




======================================================


   GDollar  NETWORKING

======================================================

GDollar Networking
-------------------------------------
N/w are essential to our life. Intenet is born due to networking and
A method of Client -server communications
gives like a house - to house interaction.

CLIENT SERVER PROGRAM
--------------------------------

<GDollar>
<%
class CLIENTSERVER
{
public  Shared void  LIB( )
{
<CLIENT>("WILMIX","1099"); // Declare client and call client and pass hostname and port
<SERVER>("1099");//Declare server and server and pass portno
}
}
%>
?>
OUTPUT:
-------
Sat Aug 22 08:52:19 GMT+00:00 2015*GDollar: Connecting to WILMIX on port 1099Waiting for client on
port 1099...Socket timed out!

=========================================================
  
MISC ,Advanced Concepts
 
=========================

Let us consider a Program to print using WHILE LOOP
Program -1
----------
<GDollar>

<%
public class WHILE
{
public  Shared void  LIB( )
{
int a=0;
while (a <=10)
{
a++;
GDollar.WriteLine("value="+a);
}
}
}
%>
?>
Compilation:
GDOLLARc WHILE.Gdollar
Output:
(note: at One time compilation you will get this output in windows platform)
********************************************************************
Tue Mar 01 1
3:30:08 IST 2016*JAS: Error:
***************************************************
******************************************
WHILE Tue Mar 01 13:30:09 IST 2016 GDollar:
Output: value=1value=2value=3value=4value=5value=6value=7value=8value=9value=10va
lue=11Error: value=1value=2value=3value=4value=5value=6value=7value=8value=9valu
e=10value=11
========================================
What is Pointers?

Variables that hold memory address are called pointers.
Why we mainly use Pointers?
Pointers reduces the length and complexity of the program,
They increase the execution speed.
It holds the memmory addres..
SYNTAX of GDollar Pointers:
---------------------------------
{*} <pointer-name> Pointers(intialvalue);
for eg)
<Str> s ="Life is beautiful";
{*} l Pointers(s);
The given above statement will store the string "Life is beautiful"
in Pointer name l;

Example:

<Str>  s="dsdds";
 
 {*} l Pointers (s);  
 
l.add(s);
for (int i = 0; i NOT= l.size(); i = i + 1)
 {
 
 <OBJECT> obj=l.GETKEY(i);
 <PRINTLN>(obj);
 
 
 
 }
what  is   the  output?
dsdds
dsdds


BUCKET
-------
Bucket are used to store key,value data, and Generated Random number
where datatype may be string ,object ,etc.
SYNTAX:
----------
Bucket<DATATYPE> list = <NEW> Bucket<DATATYPE>(<DATATYPEVALUE>);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);

Advantages
----------
Using Bucket you can also Retrieve the values stored n position.
Searching and Insertion is fast than other DTS.
Random Indexing is possible.
eg) If you store a duplicate value such Random key will be different.
It also used to add many values.
EXTEND
------
Extend class is used in GDollar since to provide multiple inheritence
about 100000000 classes . Extends class also list values in methods and
constructor values.
Extend means a Bucket contains List of class and it is also
Behave like Bucket. So it is also one of the Advanced concepts in GDollar.
SYNTAX:
--------
EXTEND <<DATATYPE>> list11 = <NEW> EXTEND <<DATATYPE>> (STRING);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);

Advantages:

It is also used to add many values
Indexing is possible
Value can also be list by index and behave like bucket.
It list only the class value and object value.
It is stateless.
PIPE:
-----
PIPE is used to maintain stateful state.
It is used for DataFlow in a Program. We can also add the values,
Constructor values of one class and other class and display it.
It also list the values from the Bucket.

SYNTAX:
-------
Pipe <<DATATYPE>> list11 = <NEW> Pipe <<DATATYPE>> (STRING);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Why we Prefer GDollar for software Field?
Used in BILLS, Forms ,Reports,Charts, any software project , GRAPHICS to web etc.


======================================================

GDollar CODING STANDARDS AND ADVANTAGES OVER OTHER
PROGRAMMING LANGUAGES

=====================================================


Coding Standards of GDollar
------------------------------
proper  syntax  fill  it...
<GDollar>
<USE> packages;
<CUTIL>
<IMPORT>  P
{
public class  <classname>
{
<! LOGIC !>
}
}




Note : 

ALL Program should Start with <GDollar> means starting of a Program and
scucceded by <IMPORT> package name
to load GDollar packages use  <CUTIL>.

HIDE Unwanted code
--------------------
<------ program code ------>
MAIN Program:
-------------
public  Shared void  LIB( ) indicates MAIN Program
otherwise it will not run the Program
STATIC BLOCK
-------------
Shared means Static keyword.
Shared will be executed first after that Main program will
be executed.
Shared
{
}
{} => This curly braces are mostly used.
SOME OPERATOR KEYWORDS
-------------------------
AND => && in java
NOT => !
# => !=
NEW Keyword
---------------
NEW is used to create an instance in memmory.
Always concenterate on important keyword not need to
memmorize at all.
DATATYPES:
-----------
int , char, double , float are ordinary keywords of oops
Programming language like C/JAVA/C#/GDollar.
STRUCTURES:
-----------
Always use Structure DATATYPE to store your data in objects form
so that it will reduce the storage allocation in memmory.
for one object it takes only 1 byte of memmory for structures.
RECYCLE:
-------
Always use RECYCLE to make the unwanted object to be garbage collected.
//
----
If you want to describe something about your functions
use // . Don't use it unnessary at any way.
Special Characters
--------------------
@,$%,^,[] are not allowed in the CDOLLLAR program
~
---
Use Destructor keyword to specify non GDollar resource deletion code to
be goes when you it..
Other Things
-------------
for loop , if statements, while loop, do while ,
for each, Switch statements, AutoBoxing , Generics , etc
are same.
Did GDollar support pointer?
-----------------------------------
YES.
private LinkedList nextNode =null;
consider this line ; This line creates a pointer to a class
LinkedList .
nextNode=new LinkedList(datum);
This statements are use to insert first data to Linkedlist
nextNode.add(datum) is used to insert many data....
Class Inheritance
-------------------
If the Class is using another class variable in that case
you had to use <--- "extends" backward arrows
and front arrows --> for implements..
Implements is used when you use friend function.

GDollar ADvantages over JAVA and other Programming Languages
------------------------------------------------------------------------

1)   GDOLLAR  PREVENTS   CODE   STEALING   SO  IT  IS    WIDELY   USED.
GDOLLAR   intermediate  code   tells   that  this   programmer  had  coded  it.
A) GDollar is the combination of JAVA , C/C++, and Advanced OOPS.
b) GDollar will only accept the shortest attractive syntax.
c) GDollar also used for construction of any datastructures.
d) GDollar helps the developers to provide inheritance by not using extends
keyword
and call the class in main program when use in linux.
e) GDollar Solves diamond Problem with multiple Inheritance when used in linux.
f) It also supports friendly function, pointers , and structures.
g) GDollar support Virtual memmory and garbage collection.
h) It is efficient, fast and easy to understand, and it is a OOPS Technology.
i) GDollar is a High level language.
j) GDollar is highly portable language
k) Using GDollar you can create any datastructures as libraries and
use it in your Application program.
l) GDollar language is a structured and object programming language.
m) GDollar has OOPS concepts like JAVA.
n) GDollar have the concept of Packages,etc.
o) GDollar have the concept of constructor or destructor and had magic oops concepts.
p) It Support functions with Default Arguments
q) It Supports Exception handling
r) It Support Generic Programming
s) It have pointer and Nodes..
t) GDollar is much simpler oops concepts, which leads to faster development and less mental
overhead.
u) GDollar is almost always explicitly compiled
w) GDollar is easy to learn. GDollar was designed to be easy to use and is therefore easy to write,
compile, debug, and learn than other programming languages.
GDollar is object-oriented. This allows you to create modular programs and reusable code.
GDollar is platform-independent.
x) GDollar creates   .exe  or  .dll   files   and  it  can be  used  with   GDollar  main  program   (CWE  EDitor  )   to  create  a  complete  software.
y) GDollar will compile and run at same time where other technology can't
do
z) GDollar is mainly used in complex programming , Billing the
goods,Graphics,etc
AA) GDollar is platform independant language
BB) GDollar is an interactive Technology.
CC) GDollar  is   used  only  in  companies  and  industries.
DD)  GDollar  is used   in  compiler design  and  datastructures construction.


=========================================================

  GDollar MAIN  Program Syntax  AND ADVANCED   CONCEPTS  PROGRAM.


=========================================================

Syntax:


<GDollar>
<INVOKE>
<PACK> <NAMESPACE>

    <CLASS> <CLASSNAME>
    {
        public FLOAT GDollar-MAIN()
        {
            
<!  GDollar  Logic  !>              
               
     



?>



BAG
=====
Bag is the extension of LinkedHashmap and it is the fastest
datastructures than
Dictionary.

SYNTAX:
=======
<GDollar>
<INVOKE>
<PACK>  bags

    <CLASS> bags
    {
        public FLOAT GDollar-MAIN()
        {
            
        Bag  b <NEW> Bag();

b.PUT(1,34); //  KEY  AS  1  AND  VALUE  AS  34
b.PUT(2,444);

<PRINTLN>(""+b);
              
               
     



?>



Bag object = new Bag();
object .put(key,value);
Functions
getValues(key) => it is used to get the values for a particular key
get(key,loc) => it is used to get the value stored at a loc (indexing
purpose)
boolean containsValue(object Value) => To check the value present in bag or
not.
put(key,value) => it is used to add key and value in Bag
remove(key ,value) => It is used to remove key and value.



TreeList
========

TreeList simillar to Bucket but store items in tree format.

TreeList list = new TreeList ("BUCKETS");
list.KeyAdd(KEY);
list.add(VALUE1);
list.RandomAdd(RANDOMNO);
list.DisplayO(list,0);


MASK
====
It is the extension of Tree Structure and it can store many values
using mask object and we can also retrieve the values stored in mask.
Mask m = new Mask(<DATATYPE>);
m.add(multiple values);
m.getR(Loc); => Get the values stored in right position
m.getL(LOC) => Get the values stored in left position


HEAP:
====


Creates a tree , puts the data into tree in a fairly balanced way and displays
the tree's size and data in a tree by performing an inorder traversal.
Heap hob = new Heap(<datatype>);
hob.add(datum);
hob = new Heap(key,value1,value2);



Bucktist
==========



Bucktist is simillar to Bucket but it is used to addd two values with one
key.
Bucktist l = null;
l= new Bucktist(key,value1,value2);


WICKET
=======
Wicket is used to store multiple values using same object with
4 values per key.

Syntax:

Wicket list12;
list12=new Wicket(key,v1,v2,v3,v4);
list12.Display();
list12.Display(list12,location);




EXAMPLE -1: BAG

<GDollar>
<INVOKE>
<PACK> MyP

    <CLASS> Programs
    {
        public FLOAT GDollar-MAIN()
        {
            
        Bag  b <NEW> Bag();

b.PUT(1,34);
b.PUT(2,444);

<PRINTLN>(""+b);
              
               
     



?>


EXAMPLE:2  : GDOLLARARRAYS
==========

<GDollar>



<PACK> MyP
{
    <CLASS> Programs
    {
         
        public FLOAT GDollar-MAIN()
        {
            


 
 
 
 <CDOLLARARRAYS> list1 <NEW>  <CDOLLARARRAYS>("ANIMALS ");
        list1.add("1 horse");
 list1.add("2 pig");
 list1.add("3 cow");
 list1.add("4 goat");
 list1.add("5 chicken");
 
 list1.add("6 ostrich");

 list1.Display();

 
              


?>


EXAMPLE-3: CREATE  AN  BOOTLOADER   Using  GDollar

 <GDollar>

<PACK>  MYOS
{
    <CLASS> MYOs
    {
public FLOAT GDollar-MAIN(){


<PRINTLN>("HelloWorld  for  booting  MYOS");

          
               
     </Statements>

?>




EXAMPE-4: POINTERS


<GDollar>
<PACK> MyP
{
    <CLASS> Programs
    {
        public FLOAT GDollar-MAIN()
        {
            

 <Str>  s="dsdds";
 
 {*} l Pointers (s);  
 
l.add(s);
 
 for (int i = 0; i NOT= l.size(); i = i + 1)
 {
 
 <OBJECT> obj=l.GETKEY(i);
 <PRINTLN>(obj);
 
 
 
 }
 
 
              
                


?>


EXAMPLE-5: DICTIONARY


<GDollar>
<USE> CUTIL; //load  CUTIL  packages
<PACK> DTS
<%
    <CLASS> roots
    {
        public FLOAT GDollar-MAIN()
{
       <Dictionary> h <NEW> <Dictionary>(11);
      h.Add((80), (90));
      h.Add((40), (400));
      h.Add((65), (650));
      h.display();

      h.Add((58), (580));
      h.Add((24), (240));
      h.display();

      h.Add((2), (20));
      h.Add((13), (130));
      h.Add((46), (460));
      h.Add((16), (160);
      h.Add((7), (77));
      h.Add((21), (271));
      h.display();

      <TRY> {h.Add((99), (990));}
      <CATCH> (<EXE> e)
      {<PRINTLN>(" out of  memory");}

      // update element
      h.Add((7), (2977));
      h.display();
   
%>

?>



Example-6: EXTEND



<GDollar>

<INVOKE>



<PACK> MyP


    <CLASS> Programs

        public FLOAT GDollar-MAIN()

        {
 
 
 EXTEND list <NEW> EXTEND("BUCKETS");
 
 
 
 
      list.KeyAdd("1101");  
                    
                     list.add("jemin");
                     
                     list.RandomAdd();    
                     
                     list.Display(list);
                    
<PRINTLN>(""+list.DisplayO(list,1));

 



?>


EXAMPLE-7: HEAP


<GDollar>


<PACK> MyP
{
      <CLASS> Programs
    {
         public FLOAT GDollar-MAIN()
        {
 

 Heap root <NEW> Heap("wilmix");
 
 for (int i = 0; i <= 10; i = i + 1)
 {
 root.add("item " + i);
 }
                 
 <PRINTLN>(root.size() );
 root.printTree();

          


?>



Example-8: LArray


<GDollar>

<USE> CUTIL;

<PACK> MyP
{
    <CLASS> Programs
    {
          public FLOAT GDollar-MAIN()
        {
 
 LArray root <NEW> LArray("root");
 
 
<ArrayList> ar <NEW> <ArrayList>();
 
 
 for  (int  i=0;i<=1000;i++)
 
 ar.add(i,i);
 
 root.add("wilmix");
 root.add("jemin");
 root.add("shalom");
 root.add("1010");
 root.add("101");
 root.add("201");
 root.add(ar.StringConvert());
 root.add("100000000");
 //print the tree's size and contents
 
 root.printTree();



          
               


?>


Example-9 : PIPE



<GDollar>

<PACK> MyP

{
    <CLASS> Programs
    {
public FLOAT GDollar-MAIN()
        {
 

Pipe list  <NEW> Pipe("BUCKETS");
 
 
 
 
      list.KeyAdd("1101");  
                    
                     list.add("jemin");
                     
                     list.RandomAdd();    
                     
                     list.Display(list);

<PRINTLN>(""+list.DisplayO(list,1));

 
          
               


?>




EXAMPLE-10: TREELIST



<GDollar>

<PACK> MyP

{
    <CLASS> Programs
    {
        public FLOAT GDollar-MAIN()
        {
 


TreeList list  <NEW> TreeList ("BUCKETS");
 
 
 
 
 
 
      list.KeyAdd("1101");  
                    
                     list.add("jemin");
                    
                     
                     list.RandomAdd("1111");   

TreeList list2 <NEW> TreeList("BUCKETS");
 list2.KeyAdd("1102");  
                    
                     list2.add("rahul");
                    
                     
                     list2.RandomAdd("1112");
                     
                 


<PRINTLN>("DATA="+list.DisplayO(list,0));


<PRINTLN>("DATA="+list2.DisplayO(list2,0));

          
               


?>


Example-11 : MASK



<GDollar>



<PACK> My
{
    <CLASS> Programs
    {
           public FLOAT GDollar-MAIN()
        {
 

 MASK root <NEW> MASK("wilmix");
 
 for (int i = 0; i NOT= 10; i = i + 1)
 {
 root.add("item " + i);
 }
             
 
 root <NEW> MASK("root1",1211211,54441);
 
 root  <NEW> MASK("root2",121121,5444);
 root  <NEW> MASK("root5",99121888,"5");
 
 root  <NEW> MASK("root3",12112,544);
 
 root  <NEW> MASK("root4",1211,54);
 
 root  <NEW> MASK("root51",121,5);
 
 
 root.printTree();
 
        
?>





Example-12 : WICKET


<GDollar>


<PACK> MyPo
{
    <CLASS> Programs
    {
           public FLOAT GDollar-MAIN()
        {
 Wicket  list12;
 list12 <NEW> Wicket(1000,10002,43433,4343,5555451);
 list12 <NEW> Wicket(10001,100021,434331,4343,5555452);
 list12 <NEW> Wicket(10002,100022,434332,4343,5555453);
 list12 <NEW> Wicket(10003,100023,434333,4343,5555454);
 list12 <NEW> Wicket(10004,100024,434334,4343,5555455);
 list12 <NEW> Wicket(10005,100025,434335,4343,5555456);
 
 
 list12.Display(list12);
 
 <PRINTLN>("DATA="+list12.DisplayO(list12,0));
                 
          
               

?>


Example-13 : STRUCTURE


<GDollar>
<PACK> MyPoi
{
    <CLASS> Programs
    {
          public FLOAT GDollar-MAIN()

        {
            

 <Str>  s="dsdds";
 
 {*} l Pointers(s);  
 
l.add(s);
 
 for (int i = 0; i NOT= l.size(); i = i + 1)
 {
 
 <OBJECT> obj=l.GETKEY(i);
 <PRINTLN>(obj);
 
 
 
 }
 
 
 
 
 <STRUCTURE>  list <NEW> <STRUCTURE> (l.GETKEY(0));
 
 for (int i11 = 0; i11 NOT= list.size(); i11 = i11 + 1)
 {
 
 
 
 <OBJECT>  el=list.ret(i11);
 

 
 <PRINTLN>("SNO= "+el);

                }
              
            
               


?>




Example-14 : BUCKETIST


<GDollar>
<INVOKE>


<PACK> MyP
{
    <CLASS> Programs
    {
          public FLOAT GDollar-MAIN()
        {
 




Bucketist  bp    <NEW>  Bucketist("wilmix");

bp    <NEW>  Bucketist(1,222,434);
bp   <NEW>  Bucketist(1,222,434);


bp.Display(bp);


<PRINTLN>("DATA="+bp.DisplayO(bp,1));
          


?>


======================================================
G  D  O  L  L  A  R   Technology focused for  Compiler Design  and  datastructures  design,Regular  Expressions,Coding  standards.
======================================================



COMPILER  DESIGN  USING  GDollar
-------------------------------------------

Introduction  of  Compiler Design
----------------------------------

What  is  Compiler?
-------------------

A   Translator    which  transforms    a  highlevel  language  such  as   CDollar, JDOLLAR,  C /C++,
Fortran  or  COBOL   into  a  Particular  computer  machine or  assembly  language
Is  called   a compiler.

What   is   Interpreter?
-------------------------
It  Process  an  internal form  of  the  source   program  and  data   at  a  same  time.
Ie,  interpretation of  the  internal  source  form    occurs  at run  time  and
No  object   program  is  generated.

A   compiler    must  perform   two  major  tasks.
a) Analysis   of  a  source   program  
b) Synthesis    of  a  corresponding  object  program

A)  Analysis    of  a  Source  program

a) Lexical   Analyser
------------------------------

That   we  know   Lexical  Analyser   is  responsible   for
Splitting    the    statements   into  tokens.
For  eg)  If  A >  B   then  is    splited   as
If    20
A  21
  >22
B   23
Then   24

Lexical  Analyzer  supplies   tokens  to  syntax
Analyzer.

b) SYNTAX   ANALYZER
------------------------------
IT's  function  is  to  take   the  source  program  from  lexical

Analyzer    and   determine   the  manner    in  which   it  is

Decomposed   into  constituent  parts.

Syntax    Analyser    outputs    a  syntax  tree   in   
Which  leaves   are  tokens  and  every  nonleaf  node  represents
A  syntactic  class  type.
SYNTACTIC  TREE   is     factor,  term  ,  expression.

Semantic  Analyser
------------------
It   is    main responsible  of  generation   of  intermediate   form  of  source  code.
Eg)
  (+ ,A,B,T1)
(+,C,D,t2)

The   output   of   semantic    Analyser  is  passed  to  code  Generator.

At   this  point  the  intermediate  form  of  the  source   program
is  usually    translated   to  either  assembly  language  or  machine   language.

The  Output   of  Code  Generator    is   passed   on to
a    code    Optimizer.

THE  CODE   OPTIMIZER
----------------------

The   Code    Optimizer   is  responsible   to  produce    a    object or   exe  or  class
Or   wl  files.


 ERROR  HANDLER
 ---------------
In compiler  design    Syntax   error  ,  invalid   characters,  out  of  memory  exception,
Checked    and   unchecked    exception    are     the    exception  occurs   if  a   new  
User    do  it. This    error   function  f(X)   is  to  determine  the   error    in source   code.
Without   error  handler   no  body   can  predict    the  errors..

SYMBOL  TABLE
-------------

A  Symbol   Table   will   contains  Variable  name,   Address, Type,  dimensions,  line  declared or  referenced,  and  pointer.
Mostly   commonly  performed   on   Symbol  table   are   insertion  and  Lookup.

STORAGE  ALLOCATION
--------------------

In  static    storage   allocation  strategy   it  is necessary   to be  able   to decide   at  compile  time
Exactly  where   each  object     will  reside    at  run time.
But  at   dynamic   storage   allocation   strategy   the  data    area  requirements   for  the  program
Are  not   known  entirely   at   compilation time.

Note: Parser  is    divided   in   to  topdown  parsing  and  bottom  up parsingÂ….
That   you  refered    through   many   websites .
THE    GDollar    for    compiler   Design

GDollar   and  it's  ADVANTAGES
--------------------------------

What  is  GDollar?  Who invented   it?  Who  should  focus  it?
GDollar  Technology  is    meant    for    Developing   a   compiler
By    using    GDollar   Technology  and  it’s  DataStructures…
which   saves  time   and  cost   and    years   ;
And    make     you    to  develop   a  compiler with   in   a  6  month.

GDollar   Technology   is  invented    by  wilmix  jemin j  in  cdollar at  first and
Fulfilled    at  year  2013  and  modified   at   C#  , JAVA , C/C++ P.L  at year  2016.

System  programmers,  Technology   inventors,  GDollar  Professionals,
And  professionals    who  are   interested   in  inventing   compiler
Should be  focused.





ABOUT GDollar
--------------

GDollar  is   an  Opensource  compiler   focused on  compiler  Design. GDollar belong  to  JAVA   or  C/C++  Group family.

GDollar is Invented in  JAVA, C/C++,   and  Editor using  Jdollar(JWEB)
GDollar virtual machine is used for 
GDollar to run  programs. G stands for Beta and Dollar stands for money.
So we called as Beta Technology.

GDollar  is  used   by  IT  companies   and  industries  in  the  world.

Syntax of GDollar:
------------------


<GDollar>

<USE> packages;

<%


<! OOPS statements  !>


%>


 ?>

 Merits of GDollar
 ------------------
> It is Good to create any compilers..

> It has simplified code

Demerits of GDollar:

It is not concenterated in creating Operating systems.
It is concenterated only in creating compilers.


How  to  compile  and  run   GDollar?

GDollarc <filename>.Gdollar



 Coding   Standards  of GDollar
 ------------------------------

<GDollar>
<USE> packages;

<%
 
 <!  LOGIC  OF  GDOLLAR  !>

%>

?> 
 
 
 Note : <%  and  %>   is  used   to  write   class   and  it's  logic.
 
 ALL  Program   should  Start   with  <GDollar>  means  starting  of   a  Program  and  succeded  by   <USE>
 
 to load  GDollar  packages  and   ?>  Means  End  of  the  Program.
 
 
 
 HIDE  Unwanted  code
 --------------------
 
 <------   program  code  ------>
 
 
 MAIN Program:
 -------------
 
 public void  GDollar-Main( )  indicates  MAIN  Program
 
 otherwise   it  will  not  run  the   Program
 
 
 STATIC  BLOCK
 -------------
 Shared  means   Static  keyword.
 
 Shared  will  be  executed  first   after that  Main program  will
 
 be  executed.
 
 
 
 Shared 
 
 {
 
 
 
 }
 
{}  =>  This  curly  braces  are mostly  used. 
 
 SOME  OPERATOR KEYWORDS
 -------------------------
 
 AND => &&  in  java
 
 NOT => !
 
 #  =>  !=
 
 
 
 <NEW>  Keyword
---------------

<NEW>  is  used  to create   an  instance   in  memmory.



Always  concenterate  on   important   keyword  not need  to
memorize  at all.


DATATYPES:
-----------


int , char,  double  , float  are  ordinary keywords    of  oops

Programming  language like  C/JAVA/CDollar.



STRUCTURES:
-----------

Always   use   Structure  DATATYPE to  store your  data  in  objects  form

so  that  it  will   reduce   the  storage  allocation   in memmory.

for  one  object  it  takes  only  1 byte of  memmory   for  structures.


RECYCLE:
-------

Always use  RECYCLE  to  make  the unwanted object  to  be    garbage  collected.



//
----


If  you want  to   describe  something about   your  functions

use  // . Don't  use  it  unnessary at  any way.



Special  Characters
--------------------

@,$%,^,[]  are  not  allowed   in  the GDollar  program


~ 
---

Use   Destructor  keyword  to  specify non GDollar  resource  deletion  code to 

be  goes when   you it..



Other  Things
-------------

for  loop  , if statements, while  loop, do  while ,

for each, Switch  statements , Generics , etc

are  same.

Did  GDollar  support pointer
-----------------------------
YES.
  
 
Class   Inheritance
-------------------

If  the  Class  is  using  another  class  variable  in  that case

you  had  to  use   <---  "extends" backward arrows  
and  front  arrows -->    for  implements..

Implements  is  used   when  you  use  friend  function.


=========================================================
        G  D  O  L  L  A  R   ADVANCED  CONCEPTS 


UNION  IN GDollar
================

SYNTAX:
==========
UNION  u =   new  UNION(string);
UNION  behave  like  structures   but  the  only  difference    is
Union has  build  in  functions like  
a)  Add(object)
b) Match(object,pos)
c)  ret(Object)
d) Size() of  object  

Advantages:
structures  is  not  used  in  the  comparision  of  values  so  union  is  used.

USECASE  in  GDollar
==================

USECASE   <Object>  =  new  USECASE(datum);
datum  may  be  datatype
  eg)  integer   or  string
<OBJECT>.Loc1(ob)
<OBJECT>.Loc2(ob)

USECASE    behaves  like   UNION   and  is  used   for  storing 
objects   at  Loc1  ,Loc2  that  has  been   used  as  a   comparision   with  mathu1,matchu2 
respectively.
and  USECASE  uses   swithcase  statement    to  asign   values 
 

ADVANTAGES:

i)  Behave like  struct
ii)  compare   the  object
iii)  Used  for  storing  objects.
iV)    it  uses   switch  case  statement

LOOP statement in  GDollar:
======================

SYNTAX:

LOOP   <Object>  =  new  LOOP(datum);
datum  may  be  datatype
  eg)  integer   or  string
<OBJECT>.Loc1(ob)
<OBJECT>.Loc2(ob)


LOOP    behaves  like   UNION   and  is  used   for  storing 
objects   at  Loc1  ,Loc2  that  has  been   used  as  a   comparision   with  mathu1,matchu2 
respectively.

ADVANTAGES:

i)  Behave like  struct
ii)  compare   the  object
iii)  Used  for  storing  objects.

BOOK  in  GDollar
==============

SYNTAX:


BOOK  <OBJECT>=   new  BOOK(string);
<OBJECT>.STOREA(object,object);
<OBJECT>.STOREB(object,object);

It  is   used    for  storing   object      with  key  and  value   in  STOREA  and  STOREB.
And  it  is  used  to  compare  with  match  statement

ADVANTAGES

i)  Book   is  used   for  storing  two  block    of  pages.
ii) it  is    used   in  case  of  storing  large   amount  of  notes  and
it  is   used  with   database.

NOTE:

Examples   for  GDollar  Advanced  Datastructures   is  given  in
AdvancedDatastructures   folders   of   GDollar  Software.
GDollar  is  powerful   than   CDollar.

How   to compile   using  GDollar  and   see   the  output?
GDollarc  <filename>.Gdollar

CJAVA Program

<CJAVA>

<PACK> LArrays
{
  
    <CLASS> LArrays
   {

   
      public void main()
      {


LArray root <NEW> LArray("root");
 
 
 
 root.add("wilmix");
 root.add("jemin");
 root.add("shalom");
 root.add("1010");
 root.add("101");
 
 
 root.add("100000000");
 //print the tree's size and contents
 
 root.printTree();




      }
   }
}

Now   compile   using  CDollacc compiler   what  it will  happen?

F:\xxxxxx\GDOLLARSOFTWARE\ORGINAL\GDollar\outputs>LArrays.cjava.exe

 1010

 wilmix

 100000000

 root

 101

 jemin

 shalom



 



======================================================
                     JDollar(JWEB)  using   C#
====================================================
SAMPLE-1: JDollar(JWEB)  with CUTIL  Packages
Program.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using CUTIL; // load  CUTIL packages
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            ArrayLinearList ar = new ArrayLinearList();
            for (int i = 0; i <= 1000; i += 1)
            {
                              if  (i/2==0)
                    ar.add(0, i);
                if (i / 3 == 0)
                    ar.add(1, i);
                else
                    ar.add(2, i);
            }

            Console.WriteLine("Elements=" + ar);
           // find  fith  element  position  and remove  that  5th  element
            ar.remove(ar.indexOf(5));
            Console.WriteLine("Elements=");
            // This  will  print  in  the  order  in  which  it  is  inserted  into  arraylist
            for (int i = ar.size()-1; i >0; i--)
            Console.WriteLine(""+ ar.get(i));
// Sort  the list  in Ascending  order
            SortedList ar1 = new SortedList(ar.size());
            for (int i = ar.size() - 1; i > 0; i--)
                ar1.Add(i,ar.get(i));
            Console.WriteLine("Elements=");
            for (int i = ar.size() - 1; i > 0; i--)
                Console.Write(" " + ar1.get(i));
            Console.ReadKey();
        }
    }
}

OUTPUT
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
957
958
959
960
961
962
963
964
965
966
967
968
969
970
971
972
973
974
975
976
977
978
979
980
981
982
983
984
985
986
987
988
989
990
991
992
993
994
995
996
997
998
999
1000
2
Elements=
 0 0 1 3 4 6 7 8 9 10 11 12
13 14 15 16 17 18 19 20 21 2
2 23 24 25 26 27 28 29 30 31
 32 33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48 49 5
0 51 52 53 54 55 56 57 58 59
 60 61 62 63 64 65 66 67 68
69 70 71 72 73 74 75 76 77 7
8 79 80 81 82 83 84 85 86 87
 88 89 90 91 92 93 94 95 96
97 98 99 100 101 102 103 104
 105 106 107 108 109 110 111
 112 113 114 115 116 117 118
 119 120 121 122 123 124 125
 126 127 128 129 130 131 132
 133 134 135 136 137 138 139
 140 141 142 143 144 145 146
 147 148 149 150 151 152 153
 154 155 156 157 158 159 160
 161 162 163 164 165 166 167
 168 169 170 171 172 173 174
 175 176 177 178 179 180 181
 182 183 184 185 186 187 188
 189 190 191 192 193 194 195
 196 197 198 199 200 201 202
 203 204 205 206 207 208 209
 210 211 212 213 214 215 216
 217 218 219 220 221 222 223
 224 225 226 227 228 229 230
 231 232 233 234 235 236 237
 238 239 240 241 242 243 244
 245 246 247 248 249 250 251
 252 253 254 255 256 257 258
 259 260 261 262 263 264 265
 266 267 268 269 270 271 272
 273 274 275 276 277 278 279
 280 281 282 283 284 285 286
 287 288 289 290 291 292 293
 294 295 296 297 298 299 300
 301 302 303 304 305 306 307
 308 309 310 311 312 313 314
 315 316 317 318 319 320 321
 322 323 324 325 326 327 328
 329 330 331 332 333 334 335
 336 337 338 339 340 341 342
 343 344 345 346 347 348 349
 350 351 352 353 354 355 356
 357 358 359 360 361 362 363
 364 365 366 367 368 369 370
 371 372 373 374 375 376 377
 378 379 380 381 382 383 384
 385 386 387 388 389 390 391
 392 393 394 395 396 397 398
 399 400 401 402 403 404 405
 406 407 408 409 410 411 412
 413 414 415 416 417 418 419
 420 421 422 423 424 425 426
 427 428 429 430 431 432 433
 434 435 436 437 438 439 440
 441 442 443 444 445 446 447
 448 449 450 451 452 453 454
 455 456 457 458 459 460 461
 462 463 464 465 466 467 468
 469 470 471 472 473 474 475
 476 477 478 479 480 481 482
 483 484 485 486 487 488 489
 490 491 492 493 494 495 496
 497 498 499 500 501 502 503
 504 505 506 507 508 509 510
 511 512 513 514 515 516 517
 518 519 520 521 522 523 524
 525 526 527 528 529 530 531
 532 533 534 535 536 537 538
 539 540 541 542 543 544 545
 546 547 548 549 550 551 552
 553 554 555 556 557 558 559
 560 561 562 563 564 565 566
 567 568 569 570 571 572 573
 574 575 576 577 578 579 580
 581 582 583 584 585 586 587
 588 589 590 591 592 593 594
 595 596 597 598 599 600 601
 602 603 604 605 606 607 608
 609 610 611 612 613 614 615
 616 617 618 619 620 621 622
 623 624 625 626 627 628 629
 630 631 632 633 634 635 636
 637 638 639 640 641 642 643
 644 645 646 647 648 649 650
 651 652 653 654 655 656 657
 658 659 660 661 662 663 664
 665 666 667 668 669 670 671
 672 673 674 675 676 677 678
 679 680 681 682 683 684 685
 686 687 688 689 690 691 692
 693 694 695 696 697 698 699
 700 701 702 703 704 705 706
 707 708 709 710 711 712 713
 714 715 716 717 718 719 720
 721 722 723 724 725 726 727
 728 729 730 731 732 733 734
 735 736 737 738 739 740 741
 742 743 744 745 746 747 748
 749 750 751 752 753 754 755
 756 757 758 759 760 761 762
 763 764 765 766 767 768 769
 770 771 772 773 774 775 776
 777 778 779 780 781 782 783
 784 785 786 787 788 789 790
 791 792 793 794 795 796 797
 798 799 800 801 802 803 804
 805 806 807 808 809 810 811
 812 813 814 815 816 817 818
 819 820 821 822 823 824 825
 826 827 828 829 830 831 832
 833 834 835 836 837 838 839
 840 841 842 843 844 845 846
 847 848 849 850 851 852 853
 854 855 856 857 858 859 860
 861 862 863 864 865 866 867
 868 869 870 871 872 873 874
 875 876 877 878 879 880 881
 882 883 884 885 886 887 888
 889 890 891 892 893 894 895
 896 897 898 899 900 901 902
 903 904 905 906 907 908 909
 910 911 912 913 914 915 916
 917 918 919 920 921 922 923
 924 925 926 927 928 929 930
 931 932 933 934 935 936 937
 938 939 940 941 942 943 944
 945 946 947 948 949 950 951
 952 953 954 955 956 957 958
 959 960 961 962 963 964 965
 966 967 968 969 970 971 972
 973 974 975 976 977 978 979
 980 981 982 983 984 985 986
 987 988 989 990 991 992 993
 994 995 996 997 998 999 100
0 2


SAMPLE-2:   Create  a  View  in  Tree Form  using
Jdollar(JWEB)   with  C#  Programming Language
a)  Arrange   WILMIX  and  his  friends  first and  after  that  other  friends, using  drag  and  drop in  tree.
b)  Prepare  a  Reservation  Form  with   fields
PassengerName , DepartedPlace ,DestinationPlace,
Ticketno, Travel Details,Transport  details.
c)  All  this    details   should  be  reflected  in   tree
format  individually; when  Add  button  is  pressed.
Solve  this  program   using  JDollar(JWEB)  Datastructures..

SAMPLE: Tree  with  Drag and  Drop using  Reservation Form
Form1.cs
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;

namespace DragDrop2
{
    /// <summary>
    /// Summary description for Form1.
    /// </summary>
    public class Form1 : System.Windows.Forms.Form
    {
        private System.Windows.Forms.TreeView treeView1;
        private TreeNode NodeToBeDeleted;
        private System.Windows.Forms.ContextMenu contextMenu1;
        private System.Windows.Forms.MenuItem menuitem_AddChild;
        private System.Windows.Forms.MenuItem menuItem_AddSib;
        private System.Windows.Forms.MenuItem menuItem_Rem;
        private TreeNode NodePt = null;
        private System.Windows.Forms.ToolBar toolBar1;
        private System.Windows.Forms.ToolBarButton toolBarButton1;
        private System.Windows.Forms.ToolBarButton toolBarButton2;

        private int nNodeCount = 0;
        private Point Position = new Point(0, 0);
        private Label label1;
        private TextBox textBox1;
        private Label label2;
        private TextBox textBox2;
        private Label label3;
        private TextBox textBox3;
        private Label label4;
        private TextBox textBox4;
        private ComboBox comboBox1;
        private Label label5;
        private Label label6;
        private TextBox textBox5;
        private Button button1;

        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public Form1()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if (components != null) 
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.Windows.Forms.TreeNode treeNode1 = new System.Windows.Forms.TreeNode("Root");
            this.treeView1 = new System.Windows.Forms.TreeView();
            this.contextMenu1 = new System.Windows.Forms.ContextMenu();
            this.menuitem_AddChild = new System.Windows.Forms.MenuItem();
            this.menuItem_AddSib = new System.Windows.Forms.MenuItem();
            this.menuItem_Rem = new System.Windows.Forms.MenuItem();
            this.toolBar1 = new System.Windows.Forms.ToolBar();
            this.toolBarButton1 = new System.Windows.Forms.ToolBarButton();
            this.toolBarButton2 = new System.Windows.Forms.ToolBarButton();
            this.label1 = new System.Windows.Forms.Label();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.textBox2 = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.textBox3 = new System.Windows.Forms.TextBox();
            this.label4 = new System.Windows.Forms.Label();
            this.textBox4 = new System.Windows.Forms.TextBox();
            this.comboBox1 = new System.Windows.Forms.ComboBox();
            this.label5 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.textBox5 = new System.Windows.Forms.TextBox();
            this.button1 = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // treeView1
            // 
            this.treeView1.AllowDrop = true;
            this.treeView1.Location = new System.Drawing.Point(0, 48);
            this.treeView1.Name = "treeView1";
            treeNode1.Name = "";
            treeNode1.Text = "Root";
            this.treeView1.Nodes.AddRange(new System.Windows.Forms.TreeNode[] {
            treeNode1});
            this.treeView1.Size = new System.Drawing.Size(192, 376);
            this.treeView1.TabIndex = 0;
            this.treeView1.ItemDrag += new System.Windows.Forms.ItemDragEventHandler(this.treeView1_ItemDrag);
            this.treeView1.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.treeView1_AfterSelect);
            this.treeView1.DragDrop += new System.Windows.Forms.DragEventHandler(this.treeView1_DragDrop);
            this.treeView1.DragEnter += new System.Windows.Forms.DragEventHandler(this.treeView1_DragEnter);
            this.treeView1.QueryContinueDrag += new System.Windows.Forms.QueryContinueDragEventHandler(this.treeView1_QueryContinueDrag);
            this.treeView1.MouseDown += new System.Windows.Forms.MouseEventHandler(this.treeView1_MouseDown);
            // 
            // contextMenu1
            // 
            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuitem_AddChild,
            this.menuItem_AddSib,
            this.menuItem_Rem});
            // 
            // menuitem_AddChild
            // 
            this.menuitem_AddChild.Index = 0;
            this.menuitem_AddChild.Text = "ADD Passengers";
            this.menuitem_AddChild.Click += new System.EventHandler(this.menuitem_AddChild_Click);
            // 
            // menuItem_AddSib
            // 
          //  this.menuItem_AddSib.Index = 1;
          //  this.menuItem_AddSib.Text = "Insert Sibling";
           // this.menuItem_AddSib.Click += new System.EventHandler(this.menuItem_AddSib_Click);
            // 
            // menuItem_Rem
            // 
            this.menuItem_Rem.Index = 2;
            this.menuItem_Rem.Text = "Remove";
            // 
            // toolBar1
            // 
            this.toolBar1.Buttons.AddRange(new System.Windows.Forms.ToolBarButton[] {
            this.toolBarButton1
           });
            this.toolBar1.DropDownArrows = true;
            this.toolBar1.Location = new System.Drawing.Point(0, 0);
            this.toolBar1.Name = "toolBar1";
            this.toolBar1.ShowToolTips = true;
            this.toolBar1.Size = new System.Drawing.Size(928, 42);
            this.toolBar1.TabIndex = 1;
            this.toolBar1.ButtonClick += new System.Windows.Forms.ToolBarButtonClickEventHandler(this.toolBar1_ButtonClick);
            // 
            // toolBarButton1
            // 
            this.toolBarButton1.Name = "ADD";
            this.toolBarButton1.Text = "ADD Passenger";
            // 
            // toolBarButton2
            // 
           // this.toolBarButton2.Name = "toolBarButton2";
           // this.toolBarButton2.Text = "Insert Sibling";
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(402, 91);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(85, 13);
            this.label1.TabIndex = 2;
            this.label1.Text = "PassengerName";
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(504, 91);
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(100, 20);
            this.textBox1.TabIndex = 3;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(402, 136);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(81, 13);
            this.label2.TabIndex = 4;
            this.label2.Text = "Departed Place";
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(504, 136);
            this.textBox2.Name = "textBox2";
            this.textBox2.Size = new System.Drawing.Size(100, 20);
            this.textBox2.TabIndex = 5;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(402, 183);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(90, 13);
            this.label3.TabIndex = 6;
            this.label3.Text = "Destination Place";
            // 
            // textBox3
            // 
            this.textBox3.Location = new System.Drawing.Point(504, 180);
            this.textBox3.Name = "textBox3";
            this.textBox3.Size = new System.Drawing.Size(100, 20);
            this.textBox3.TabIndex = 7;
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(402, 224);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(49, 13);
            this.label4.TabIndex = 8;
            this.label4.Text = "Ticketno";
            // 
            // textBox4
            // 
            this.textBox4.Location = new System.Drawing.Point(504, 221);
            this.textBox4.Name = "textBox4";
            this.textBox4.Size = new System.Drawing.Size(100, 20);
            this.textBox4.TabIndex = 9;
            // 
            // comboBox1
            // 
            this.comboBox1.FormattingEnabled = true;
            this.comboBox1.Items.AddRange(new object[] {
            "TAXI",
            "MiniBus",
            "GovtBus",
            "VolvaBus"});
            this.comboBox1.Location = new System.Drawing.Point(504, 274);
            this.comboBox1.Name = "comboBox1";
            this.comboBox1.Size = new System.Drawing.Size(121, 21);
            this.comboBox1.TabIndex = 10;
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(405, 281);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(64, 13);
            this.label5.TabIndex = 11;
            this.label5.Text = "Travel Type";
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Location = new System.Drawing.Point(405, 319);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(90, 13);
            this.label6.TabIndex = 12;
            this.label6.Text = "Transport  Details";
            // 
            // textBox5
            // 
            this.textBox5.Location = new System.Drawing.Point(504, 319);
            this.textBox5.Name = "textBox5";
            this.textBox5.Size = new System.Drawing.Size(121, 20);
            this.textBox5.TabIndex = 13;
            // 
            // button1
            // 
            this.button1.BackgroundImage = global::DragDrop2.Properties.Resources.thumb_1920_112347;
            this.button1.Location = new System.Drawing.Point(467, 368);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(75, 23);
            this.button1.TabIndex = 14;
            this.button1.Text = "ADD";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // Form1
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.BackColor = System.Drawing.SystemColors.ActiveCaption;
            this.ClientSize = new System.Drawing.Size(928, 429);
            this.Controls.Add(this.button1);
            this.Controls.Add(this.textBox5);
            this.Controls.Add(this.label6);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.comboBox1);
            this.Controls.Add(this.textBox4);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.textBox3);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.textBox2);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.textBox1);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.toolBar1);
            this.Controls.Add(this.treeView1);
            this.Name = "Form1";
            this.Text = "RESERVATION FORM";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }
        #endregion

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main() 
        {
            Application.Run(new Form1());
        }

        private void treeView1_AfterSelect(object sender, System.Windows.Forms.TreeViewEventArgs e)
        {

        }

        private void treeView1_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
        }

        private void treeView1_ItemDrag(object sender, System.Windows.Forms.ItemDragEventArgs e)
        {
            NodeToBeDeleted = (TreeNode)e.Item;
            string strItem = e.Item.ToString();
            DoDragDrop(strItem, DragDropEffects.Copy |  DragDropEffects.Move);
        }

        private void treeView1_QueryContinueDrag(object sender, System.Windows.Forms.QueryContinueDragEventArgs e)
        {
        }

        private void treeView1_DragEnter(object sender, System.Windows.Forms.DragEventArgs e)
        {
                if (e.Data.GetDataPresent(DataFormats.Text)) 
                    e.Effect = DragDropEffects.Move;
                else
                    e.Effect = DragDropEffects.None;
        }
        private void Form1_Load(object sender, System.EventArgs e)
        {
        
        }

        private void treeView1_DragDrop(object sender, System.Windows.Forms.DragEventArgs e)
        {
            Position.X = e.X;
            Position.Y = e.Y;
            Position = treeView1.PointToClient(Position);
            TreeNode DropNode = this.treeView1.GetNodeAt(Position);
            if (DropNode != null && DropNode.Parent == this.NodeToBeDeleted.Parent )
            {
                TreeNode DragNode = this.NodeToBeDeleted;
                DropNode.Parent.Nodes.Remove(this.NodeToBeDeleted);
                DropNode.Parent.Nodes.Insert(DropNode.Index+1, DragNode);
            }
        }

    
        private void menuitem_AddChild_Click(object sender, System.EventArgs e)
        {
            
            
        }
        private void menuItem_AddSib_Click(object sender, System.EventArgs e)
        {
            
                
        }


       static  int counter = 0;
        private void toolBar1_ButtonClick(object sender, System.Windows.Forms.ToolBarButtonClickEventArgs e)
        {
            NodePt = this.treeView1.SelectedNode;
            switch(toolBar1.Buttons.IndexOf(e.Button))
            {
                case 0:
                {
                    if(NodePt != null && NodePt == this.treeView1.SelectedNode)
                    {
                        TreeNode NewNode = new TreeNode();

                        String  s=" ";

                        counter = b.size() / 6;

                    

                        if (counter == 1)
                            counter = 0;

                        if (counter > 1)

                            counter = (counter - 1) * 6;



                        for  (int i=counter;i<b.size();i++)
                           s = " "+ s  + b.ret(i).ToString();

                        NewNode.Text  = s;
                    
                        if(NodePt.GetNodeCount(false) != 0)
                            this.NodePt.Nodes.Insert(NodePt.GetNodeCount(false) , NewNode);
                        else
                            this.NodePt.Nodes.Add(NewNode);
                        nNodeCount ++;
                    }
                }
                break;
                case 1:
                {
                    if(NodePt != null && NodePt == this.treeView1.SelectedNode)
                    {
                        TreeNode NewNode = new TreeNode();

                        String s = " ";

                        counter = b.size() / 6;

                       

                       
// if  one   batch  value  is  inserted  from GUI , then  assign  //counter=0
 if (counter == 1)
                            counter = 0;
// If  more  than  one  batch  value  is  inserted  from GUI
//then  use  the  formulae  counter=(counter-1) *6
                        if (counter > 1)

                            counter = (counter - 1) * 6;
// 6 indicates  6 fields


                        for (int i = counter; i <= b.size(); i++)
                            s = " " + s + b.ret(i).ToString();

                        NewNode.Text = s;
                    
                        this.NodePt.Parent.Nodes.Insert(NodePt.Index + 1 , NewNode);
                        nNodeCount ++;
                    }
                }
                break;

            }

        }

        gdollarlib.BOOK b = null;
        
        private void button1_Click(object sender, EventArgs e)
        {

            string selected = this.comboBox1.GetItemText(this.comboBox1.SelectedItem);
     
            b = new gdollarlib.BOOK(selected);
//  add   all  the   textbox  and  combox values  to  Book  -dts
//of  JDollar-Gdollar
            b.add(textBox1.Text);
            b.add(textBox2.Text);
            b.add(textBox3.Text);
            b.add(textBox4.Text);
            b.add(textBox5.Text);

          

        

           
           
        }

    }
}

Input


OUTPUT

After  drag and drop  arrangement  ...


Note:  Sheeba  is  not  friend  ; but  andrew,brito,alice, hiram 
are  friends  for  wilmix. so   the   tree is  arranged  by  drag  and  drop  manner  with  wilmix friends.
Now  using    JDollar(JWEB)    with C#  solves  a  complex Tree 
problem...

=======================================
JDollar(JWEB)  Concepts  -Part1
=================================
Program-1: JWEB  using  WNOSQLDB

<JDollar>

<USE> WDBA; //load  wdba packages
<USE> CDollar.WDBA; // load  wnosql packages
<IMPORT>
<PACK> MyP
{
    <CLASS> Programs
    {
          public void main()
        {
        // add  some elements  to  LArray  so
//  that  it  print  in  tree  format
    LArray root <NEW> LArray("root");
        root.add("wilmix");
        root.add("jemin");
        root.add("shalom");
        root.add("1010");
        root.add("101");
        root.add("201");
        
        root.add("100000000");
        //print the tree's size and contents
        root.printTree();


<TRY>
{

    string g = WDBASQL.WDBASQLS("datastores", "USEDATABASE", "dbpwds", "C:\\Programs\\WNOSQL\\WNOSQLProgramfiles\\WNOSQL-cod");

    string t = WDBASQL.WDBASQLS("dbuser", "dbpwds", 1, "wilmix78", "wilmix78", 1, 5, g);
//list  Telecom  table  values  from  3  to  29  cols
    string s1 = "SelectAll from Telecom 3 to 29 , 1 to 7 ?= C By 1 1 : {0} : {0} :{0}";

ArrayList  arf= WDBALIB.WDBAQUERY(s1, t);

<PRINTLN>(""+arf);

}

<CATCH> (<EXE> e) { }        
}

}
}


Program-2:  If  you  want  to  create a explorer  by
limited  code  what  is   the  Jdollar program  for  that?

<JDollar>

<USE> browser;
<PACK> GEXPLORER
{
  
    <CLASS> GEXPLORER
   {

   
      public void main()
      <%
        
FileBrowser.call();


      }
   }
}

Program-3:  Write   a  JWEB  to  perform  swapping  the
two  given  elements  a, b.

<JDollar>
<USE> CUTIL;
<PACK> ConsoleApplication1
{
    <CLASS> Program
    {
        public void main()
        {
ArrayList  ar  =  new  ArrayList();
ar.add(0,2000);
ar.add(1,3000);
logic(ar.get(0).ToString(),ar.get(1).ToString());
        }
public Shared  void  logic(String  x ,String  y)
{
<PRINTLN>("Initial value of x: "+x+" and y: "+y);
 x =y;
y=x;
 <PRINTLN>("After swapping value of x: "+x+" and y: "+y);
}


    }
}

Program-4:  Create   and  Employee  table  with  4 fields
ENO,ENAME,DESIGNATION,SALARY
Perform    a) List  b)  Update c) Insert  Operations

<JDollar>

<USE> WDBA;
<USE> CDollar.WDBA;
<USE> CUTIL;
<PACK> ConsoleApplication1
{
    <CLASS> Program
    {
        public void main()
        {
            String g = WDBASQL.WDBASQLS("datastores", "USEDATABASE", "dbpwds", "C:\\Programs\\WNOSQL\\WNOSQLProgramfiles\\WNOSQL-cod");
            String t = WDBASQL.WDBASQLS("dbuser", "dbpwds", 1, "wilmix78", "wilmix78", 1, 5, g);
// create  a  table  with   4  fields  eno,ename,Designation,salary
so  (location  0,1,2,3}  is  allocatd  for  fields  insertion
            String s1 = "CREATETABLE from Employee 0 to 0 , 1 to 6 ?= X By 1 1 : {ENO,ENAME,DESIGNATION,SALARY}: {0} :{0}";
          <PRINTLN>("" + WDBALIB.WDBAQUERY(s1, t));
//list  the  employee
            String s11 = "SELECTRVAL from Employee 0 to 0 , 1 to 6 ?= X By 1 1 : {0} : {0} :{0}";
            <PRINTLN>("" + WDBALIB.WDBAQUERY(s11, t));
// since  0,1,2,3 locations are  already  allocated  by fields so insert  into  employee  starting  from   4  cols  by  calculating  size  of table //size.  and  now  you  insert   2 records 
// {2,jemin,sse2,300000,3,shyam,mgr,500000} 
            String s12 = "INSERTINTO from Employee 4 to " + WDBALIB.WDBAQUERY(s11, t).size() + " , 1 to 6 ?= X By 1 1 : {0} : {2,jemin,sse2,300000,3,shyam,mgr,500000} : {0}";
            <PRINTLN>("" + WDBALIB.WDBAQUERY(s12, t));
//  list  all  the  employees
            String s112 = "SELECTRVAL from Employee 0 to 0 , 1 to 6 ?= X By 1 1 : {0} : {0} :{0}";
            <PRINTLN>("" + WDBALIB.WDBAQUERY(s112, t));
//  update  the  Employee table  change  shyam name  to   sriram
            String s171 = "UPDATE from Employee 0 to 0 , 1 to 6 ?= C By 1 1 : {shyam} :{sriram}:{0}";
// print    the  employee  table  contents.
            <PRINTLN>("" + WDBALIB.WDBAQUERY(s171, t));
        }
    }
}


JDOLLAR-JAVA

Program-1 : Add  some  elements  to  LArray  and
print it  in  tree format using  JDollar:

<JDollar> -> Starting of  JDollar  program


<USE> <JJAVA>.util; //load  Jdollar-java util packages

<PACK> p // <PACK>  means  namespace


{

<CLASS> abc
{
public void main()

{

LArray root <NEW> LArray("root");
        
        <AList>  ar <NEW>  <AList>();
        
        
        for  (int  i=0;i<=1000;i++)
        
        ar.add(i);
        
        root.add("wilmix");
        root.add("jemin");
        root.add("shalom");
        root.add("1010");
        root.add("101");
        root.add("201");
        root.add(ar.StringConvert());
        root.add("100000000");
        //print the tree's size and contents
        
        root.printTree();




}

}

}

Program-2: Example   for  BAG,Hashtable

<JDollar>


<USE> CUTIL;

<PACK> p1


{

<CLASS> abc11
{
public void main()

{




 Bag  tree <NEW> Bag();
 //  Bag  is  used to  maintain  Hirerachial  arrangement
//of  data;  that  you already learnt  in  cdollar
  Bag  Member <NEW> Bag();

       
Member.PUT("A","CLASS5");
Member.PUT("B","CLASS5");
Member.PUT("C","CLASS5");
Member.PUT("D","CLASS5");
Member.PUT("CLASS6","CLASS6");
 Bag  slibings <NEW> Bag();
slibings.PUT("A","s1");
slibings.PUT("A","s2");
slibings.PUT("B","s11");
slibings.PUT("B","s21");
slibings.PUT("C","s12");
slibings.PUT("C","s22");
Bag  activity <NEW> Bag();
activity.PUT("s1","cricket");
activity.PUT("s2","read");
activity.PUT("s21","swim");
activity.PUT("s12","swim");
tree.PUT(1,Member);
tree.PUT(2,slibings);
tree.PUT(3,activity);


activity.remove("s1","cricket");
tree.remove(3,activity);
tree.PUT(3,activity);

<PRINTLN>("output="+tree.containsValue(Member));
           
// it  is  used   to  return  sin value
      <PRINTLN> (""+Math.Sin(10)); 


// assign  2 elements in  hashtable  and  print it
HashTable h  <NEW> HashTable(2);
      h.put(1,1);      h.put(2,890 ); h.display();

}

}

}


E:\Programs\JDOLLARJAVA>abc11.jdollar.exe
output=True
-0.54402111088937
56
890
1
======================================================
UNIT-6 :  JDOLLAR(JWEB)   with  JWP
==============================================================================
JDOLLAR  with  JWP


Program-1  :  Create  a   Register page  and  print   the   form value  in  table  format

index.jwp

<JDWEB>
<PACK>
<%
public class index {
 public void  JWP-Main( )
{
HTML.displayhtml("Register.html");
}
}
%>
</JDWEB>

Jquerytest.j$

<?CHDollar>  // Remotewebapplication-type-2

<USE> <WEB>.util; // load  CH$  util  packages


<PACK> Program5 // <PACK>  means  namespace
{
  
    <CLASS> Prog // <CLASS> means  class
   {

  
      public void Main() //  main  of  CH$ Program
      {

ArrayList arm1= new ArrayList();


arm1.add(0,"name");
arm1.add(1,"uname");arm1.add(2,"password");
arm1.add(3,"state");
arm1.add(4,"coun<TRY>");
arm1.add(5,"spwd");
arm1.add(6,"stext");
arm1.add(7,"familydet");
arm1.add(8,"Indent");
arm1.add(9,"CIndent");

arm1.add(10,"NOT");

<PRINTLN>("<HTML>");

<PRINTLN>("<BODY bgcolor=pink>");

<PRINTLN>("<form>");
 
  

ArrayList  armg= Request.Query(arm1,"Jquerytest.j.dsn",10,1);
//  10  fields    ,  incremented  by  1 ,  get  response  data  from
// Jquerytest.j.dsn
 <PRINTLN>("<table style='width:100%' bgcolor=gold>");

<PRINTLN>("<tr>");

<PRINTLN>("  <th>Name</th>");
  
<PRINTLN>("  <th>Username</th>"); 
  
<PRINTLN>("  <th>Password</th>");
  
<PRINTLN>("  <th>State</th>");
  
<PRINTLN>("  <th>Coun<TRY></th>");
  
<PRINTLN>("  <th>Confirm Password</th>");

<PRINTLN>("  <th>Secret Password</th>");

<PRINTLN>("  <th> FamilyDetails </th>");
<PRINTLN>("  <th>Percentage of Marks Scored</th>");
<PRINTLN>("  <th>Subject</th>");
   
<PRINTLN>(" </tr>");
   
<PRINTLN>(" <tr>");



for (int i=armg.size()-10;i<armg.size();i++)
{

//  print   it  in  table  format
   <PRINTLN>("<td>"+armg.get(i)+"</td>");
   
 }

  
<PRINTLN>(" </tr>");
 
  
<PRINTLN>("</table>");


<PRINTLN>("</form>");

<PRINTLN>("</html>");
      
 

        
}


}

}

Input:


OUTPUT


Program-2: Insurance
insur.jwp

<JDWEB>
<PACK>
<%
public class insur {
<INSURANCE>  // declare  this  as  Insurance programme
</INSURANCE>  // close  the  program
 public void  JWP-Main( )
{

HTML.displayhtml("insurance.html");
<HMAP> mp = <NEW> <HMAP>();
mp.PUT(1,30);
// put  30  at  key  1
JDollar.Writeln(""+"<p> Enter Your Taxable  amount <input type=text name=TAX size=5 value="+INSURANCEBean (mp).get(1)+" />"); //  assign  30 at  the  textbox
HTML.displayhtml("insurance1.html");
}
}
%>
</JDWEB>


<JDollar>

<USE> <WEB>.util; 


<PACK> Program5
{
  
    <CLASS> Prog
   {

  
      public void Main()
      {

ArrayList arm1= new ArrayList();


arm1.add(0,"name");
arm1.add(1,"uname");arm1.add(2,"password");
arm1.add(3,"state");
arm1.add(4,"coun<TRY>");
arm1.add(5,"spwd");
arm1.add(6,"stext");
arm1.add(7,"familydet");
arm1.add(8,"Indent");
arm1.add(9,"TAX");

arm1.add(10,"NOT");

<PRINTLN>("<HTML>");

<PRINTLN>("<BODY bgcolor=pink>");

<PRINTLN>("<form>");
 
  

ArrayList  armg= Request.Query(arm1,"Jquerytest1.j.dsn",10,1);
 <PRINTLN>("<table style='width:100%' bgcolor=gold>");

<PRINTLN>("<tr>");

<PRINTLN>("  <th>Name</th>");
  
<PRINTLN>("  <th>Username</th>"); 
  
<PRINTLN>("  <th>Password</th>");
  
<PRINTLN>("  <th>State</th>");
  
<PRINTLN>("  <th>Coun<TRY></th>");
  
<PRINTLN>("  <th>Confirm Password</th>");

<PRINTLN>("  <th>Secret Password</th>");

<PRINTLN>("  <th> FamilyDetails </th>");
<PRINTLN>("  <th>Vehicle Amount</th>");
<PRINTLN>("  <th>Taxable  amount</th>");
   
<PRINTLN>(" </tr>");
   
<PRINTLN>(" <tr>");



for (int i=armg.size()-10;i<armg.size();i++)
{


   <PRINTLN>("<td>"+armg.get(i)+"</td>");
   
 }

  int  tax= Convert.ToInt32(armg.get(armg.size()-1));

 int  tamt= Convert.ToInt32(armg.get(armg.size()-2)) * tax/100;
<PRINTLN>("<td>TOTAL AMT  for  viva insurance="+tamt+"</td>");

<PRINTLN>(" </tr>");
 
  
<PRINTLN>("</table>");


<PRINTLN>("</form>");

<PRINTLN>("</html>");
      
 

        
}


}

}

INPUT


OUTPUT:



CHDOLLAR  WITH  JWP

Chdollar  with  JWP  is  focused  on Chdollar  with
Jdollar  interaction.

SYNTAX:


<JDWEB>
<PACK>
<%
public class index {
<J$MISC>
<! logic !>
</J$MISC>

 public void  JWP-Main( )
{
<! JWP  Logic  !>
}
}
%>
</JDWEB>


Example-1


 <JDWEB>

<PACK>
<%

public class index {

<J$MISC>
form.put("wil","11");
</J$MISC>


 public void  JWP-Main( )
{
HTML.displayhtml("Register.html");
<HMAP> mp = <NEW> <HMAP>();
mp.PUT("111",776);
JDollar.Writeln(""+MISCBean(mp));
}
}
%>
</JDWEB>


Input



Output:




FAQS?

Why  we  use  the  following  code in .j$  which  is  given below?


.......
.......
.....

<J$MISC>
<! logic !>
</J$MISC>
.....
.....
.....

Since  <J$MISC>  indicates  other  domains  like
Reservation,etc.

CH$  with  CDollar ,JDollar oops and 
====================================
 GDollar  oops  concepts
=============================================


JDollar OOPS  like  Linear List ,ArrayLinearList,etc.
And  CDollar oops  like  Bag  dts  is  followed  for  tree  
datastrucures.

And  GDollar oops  like BOOKS,LOOPS,UNION,and ,USERCASE  is
followed   for  CHDollar.

Shopping cart  using CDollar  dts

Example for  Shopping  cart


<JDollar>




<PACK> Program5
{
  
    <CLASS> Prog
   {

  
      public void Main()
      {


 Bag  Member <NEW> Bag();

       
Member.PUT("A","Price:$2");
Member.PUT("B","Price:$32");
Member.PUT("C","Price:$45");
Member.PUT("D","Price:$12");
Member.PUT("E","Price:$15");
Member.PUT("F","Price:$15");
//put  price  values  in  A,B,C,D,E,F  
//  and  get  the  value  using  Member.get("A")  and so-on


HTML.displayhtml("shoppingcart.html");

<PRINTLN>("<div class=products>");
        <PRINTLN>("<ul>");
            <PRINTLN>("<li>");
                <PRINTLN>("<a href=# <CLASS>=item>");
                    <PRINTLN>("<img src=http://www.jeasyui.com/tutorial/dd/images/shirt1.gif>");
                    <PRINTLN>("<div>");
                    <PRINTLN>("<p>Balloon Shirts</p>");
                        <PRINTLN>("<p>"+Member.get("A").ToString().Replace("[","").Replace("]","")+"</p>");
                    <PRINTLN>("</div>");
                <PRINTLN>("</a>");
            <PRINTLN>("</li>");
            <PRINTLN>("<li>");
                <PRINTLN>("<a href=# <CLASS>=item>");
                    <PRINTLN>("<img src=http://www.jeasyui.com/tutorial/dd/images/shirt2.gif>");
                    <PRINTLN>("<div>");
                        <PRINTLN>("<p>Feeling Shirts</p>");
                        <PRINTLN>("<p>"+Member.get("B").ToString().Replace("[","").Replace("]","")+"</p>");
                    <PRINTLN>("</div>");
                <PRINTLN>("</a>");
            <PRINTLN>("</li>");
            <PRINTLN>("<li>");
                <PRINTLN>("<a href=# <CLASS>=item>");
                    <PRINTLN>("<img src=http://www.jeasyui.com/tutorial/dd/images/shirt3.gif>");
                    <PRINTLN>("<div>");
                        <PRINTLN>("<p>Elephant Shirts</p>");
                        <PRINTLN>("<p>"+Member.get("C").ToString().Replace("[","").Replace("]","")+"</p>");
                    <PRINTLN>("</div>");
                <PRINTLN>("</a>");
            <PRINTLN>("</li>");
            
        <PRINTLN>("</ul>");
    <PRINTLN>("</div>");

HTML.displayhtml("shoppingcart1.html");



    
    
        
}


}

}
